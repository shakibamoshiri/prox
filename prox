#!/bin/bash
#
#
# full AAA server for shadowsocks in sing-box
# frontend: Bash
# backend: sing-box proxy v1.12 and upper
#
# Shakiba Moshiri (C) 20XX


################################################################################
# bash strict mode
################################################################################
private::strict_mode(){
    set -T # inherit DEBUG and RETURN trap for functions
    set -C # prevent file overwrite by > &> <>
    set -E # inherit -e
    set -e # exit immediately on errors
    set -u # exit on not assigned variables
    set -o pipefail # exit on pipe failure
    shopt -s extglob
}
private::strict_mode;

################################################################################
# handle debugging
################################################################################
function __error_handing__(){
    local last_status_code=$1;
    local error_line_number=$2;
    echo 1>&2 "Error - exited with status $last_status_code at line $error_line_number";
    perl -slne 'if($.+5 >= $ln && $.-4 <= $ln){ $_="$. $_"; s/$ln/">" x length($ln)/eg; s/^\D+.*?$/$&/g;  print}' -- -ln=$error_line_number $0
    echo;
}

# function __debug_handing__() {
#     echo "DEBUG [${BASH_COMMAND[0]}] [$?]"
#     sleep 0.1
# }

# function __exit_handing__(){
#     printf '\n%s\n' ${FUNCNAME}
# }

# trap '__error_handing__ $? $LINENO' ERR
# trap '__exit_handing__ $?' INT TERM EXIT
# trap '__debug_handing__ $? $LINENO' DEBUG


### immutable variables
declare -ir ERR_EXPR_FAILED=1;
declare -ir ERR_FILE_NOT_FOUND=2;
declare -ir ERR_OPTION_NOT_FOUND=3;
declare -ir EXIT_SUCCESS=0;
declare -ir CLI_PPID=$$;

declare -r PS4='debug($LINENO) ${FUNCNAME[0]:+${FUNCNAME[0]}}(): ';
declare -r CLI_NAME='prox';
declare -r CLI_VERSION='0.9.0';
declare -r CLI_SOURCE_LINK='https://github.com/shakibamoshiri/prox';
declare -r CLI_INSTALL_PATH='/usr/local/bin';
declare -r PRINTF_HELP_OFFSET=20;
declare -r PRINTF_APP_TEST_OFFSET=30;

declare -r ANSISHELL_HEADER="full AAA wrapper for shadowsocks in sing-box";

declare -rA main_cmds=(
    [h]=help
    [help]=help

    [a]=app
    [app]=app

    [u]=user
    [usr]=user
    [user]=user

    [s]=server
    [srv]=server
    [serv]=server
    [server]=server

    [ag]=agent
    [agent]=agent

    [d]=data
    [db]=data
    [data]=data

    [t]=telegram
    [tell]=telegram
    [telegram]=telegram
)

declare SCRIPT_DEBUG_FLAG=false


################################################################################
# app configuration
################################################################################
declare -r __pool_path=".${CLI_NAME}/pool";
declare -r __agent_path=".${CLI_NAME}/agent";
declare -r __log_path=".${CLI_NAME}/log";
declare -r __tmp_path=".${CLI_NAME}/tmp";


################################################################################
# utilities
################################################################################
private::info() { 
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "\033[1;34m${*:2}\033[0m"; 
    fi
}

private::warn() { 
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "\033[1;33m${*:2}\033[0m" 1>&2; 
    fi
}

private::error(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "\033[1;31m${*:2}\033[0m" 1>&2;
    fi
}

private::title(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "\033[1;37m${*:2}\033[0m\n";
    else
        printf "\033[1;37m${*:2}\033[0m\n" >> $__log_path/silent.txt 2>&1
    fi
}

private::print() { 
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "${*:2}\n";
    else
        printf "${*:2}\n" >> $__log_path/silent.txt 2>&1
    fi
}

private::printf(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "${*:2}-" "-" | tr ' -' '. ';
    fi
}

function reply_msg(){
    private::debug $LINENO "@: ${@}";

    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    private::debug $LINENO "args[@]: ${args[@]}";
    private::debug $LINENO "!args[@]: ${!args[@]}";

    declare -r newline="${args[newline]:+$'\n'}"
    declare -r result="${args[res]:-undefined}"
    declare -ir return=${args[return]:-0}
    declare -r show=${args[show]:-false}

    if [[ ${show} == false ]]; then
        return 0
    fi

    declare -r final_reply_msg="${newline}res: $result
aid: ${agent_info[id]:-undefined}
pid: ${pool_info[id]:-undefined}
agn: ${agent_info[groupname]:-undefined}
usr: <code>${username:-${new_username:-undefined}}</code>"

    printf "$final_reply_msg\n"

    return ${return:-0}
}

################################################################################
# jq / yq functions
################################################################################
jq::summary(){
    declare -r server=${1##*/}
    declare -ir count=${2}
    declare -r active=${3:-all}


    if (( $count == 0 )); then
        jq --null-input '{ user: "undefined", byte: "?", sessions: "?", server: "'$server'"}'
    else
        case $active in
            true )
                jq --exit-status '
                    .server_loc as $location |
                    .users[] |
                    select((.downlinkBytes + .downlinkBytes) != 0) |
                {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }' || \
                jq '
                    .server_loc as $location |
                {
                    user: "?",
                    byte: "?",
                    session: "?",
                    active: "?",
                    server: $location
                }' < $api_addr_json_file
            ;;
            false )
                jq '
                    .server_loc as $location |
                    .users[] |
                    select((.downlinkBytes + .downlinkBytes) == 0) | {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }'
            ;;
            all )
                jq '
                    .server_loc as $location |
                    .users[] | {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }'
            ;;
        esac
    fi
}

jq::table(){
    if [[ $1 == true ]]; then
        jq -sr  '. as $root | $root[0] | to_entries | map(.key) | join(" ") as $H | $H, ($root[] | to_entries | map(.value|tostring) | join(" "))' | \
        column -t
    else
        jq
    fi
}

yq::table(){
    if [[ $1 == true ]]; then
        yq -r '. as $R | ($R[0] | to_entries | map(.key) | join(" ")) as $H | ($H, $R[] | to_entries | map(.value) | join(" "))' | \
        column -t
    else
        yq '.'
    fi
}

jq::user_stat(){
    jq '.users | map({user: .username, bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
        jq '.[] | select(.user=="'$username'")' | \
        jq -s '{ user: .[0].user, bytes: (map(.bytes)|add), sessions: (map(.sessions)|add) }'
}

jq::user_init(){
    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r user=${args[user]:-undefined};

    jq --null-input '
        ($config[0].day * 24 * 60 * 60) as $duration |
        ($config[0].gig * 1024 * 1024 * 1024) as $base |

    {
        user: $config[0].username,
        sessions: 0,
        ctime: (now|floor),
        atime: 0,
        etime: ((now|floor)+$duration),
        bytes: {
            base: $base,
            used: 0,
            pday: 0,
            limit: false
        },
        seconds: {
            base: $duration,
            used: 0,
            limit: false
        }
    }' --slurpfile config $table_users/${user}.json
}

jq::user_update(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r delink=${args[delink]:-false};
    declare -r user_bytes_file=${table_bytes}/${user}.json

    declare -i last_bytes=$(private::user_bytes user=$user)
    declare -i user_bytes=$(jq '.bytes.used' < $user_bytes_file)
    if (( last_bytes == user_bytes )); then
        echo ignored
        return 0
    fi

    private::user_stat user=$user caller=$fn_name | \
    jq '
        ($log[0]) as $log |
        ((now|floor)-$log.ctime) as $second_used |
        ((((now|floor)-$log.ctime)/(24*60*60))|floor)  as $day_used |
        (.bytes / (if ($day_used==0) then 1 else $day_used end)) as $pday |

    {
        user: .user,
        sessions: .sessions,
        ctime: $log.ctime,
        atime: (now|floor),
        etime: $log.etime,
        bytes: {
            base: $log.bytes.base,
            used: .bytes,
            pday: $pday,
            limit: (.bytes > $log.bytes.base)
        },
        seconds: {
            base: $log.seconds.base,
            used: $second_used,
            limit: ($second_used > $log.seconds.base)
        }
     }
    ' --slurpfile log $user_bytes_file | \
    sponge $user_bytes_file
    echo 'updated'

    ### generate a static page for it
    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$user
    declare -r user_profile_index_html=$user_profile_path/index.html
    declare -r user_fetch_file=$user_profile_path/${user}.json

    # declare -r bytes_used=$(jq '.bytes.used' < $user_bytes_file)
    # declare -r seconds_used=$(jq '.seconds.used' < $user_bytes_file)
    # declare -r sessions=$(jq '.sessions' < $user_bytes_file)

    # ### update user data on index.html
    # perl -i -s -lpe 's/(?<=id="user-bytes">)\d*(?=<\/span>)/$arg/' -- -arg=$bytes_used $user_profile_index_html
    # ### day
    # perl -i -s -lpe 's/(?<=id="user-seconds">)\d*(?=<\/span>)/$arg/' -- -arg=$seconds_used $user_profile_index_html
    # ### sessions
    # perl -i -s -lpe 's/(?<=id="user-sessions">)\d*(?=<\/span>)/$arg/' -- -arg=$sessions $user_profile_index_html

    # if ! [[ -f $user_fetch_file ]]; then
    if jq --exit-status '.bytes.used == 0' < $user_fetch_file > /dev/null 2>&1; then
        if [[ $delink == true ]]; then
            ### remove the link, should we ?
            perl -i -s -lpe 's/(?<=value=").*?(?=")/$arg/' -- -arg="removed-by-admin" $user_profile_index_html
            perl -i -s -lne '!/$arg/ && print' -- -arg='img src=' $user_profile_index_html
            rm -f ${user_profile_path}/!(index.html)
        fi
    fi

    rsync -az $user_bytes_file $user_profile_path/
}

################################################################################
# user command
################################################################################
private::user_create(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r force=${args['force']:-false}

    declare -r username_random=$(openssl rand -hex 5)
    declare -r profile_random=$(openssl rand -hex 5)
    declare -r username=${args['user']:-$username_random}
    declare -r user_gig=${args[gig]:-${pool_info[gig]}}
    declare -r user_day=${args[day]:-${pool_info[day]}}

    declare -r user_realname=${args['rname']:-${args['rn']:-}}
    declare -r profile_name=${args['pname']:-${args['pn']:-}}

    declare -r password=$(openssl rand -base64 16)
    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r user_data_file=${table_users}/${username}.json
    declare old_password=""

    if [[ -z $user_realname ]]; then
        reply_msg res='error, name of the user, rn=NAME' \
            return=$ERR_EXPR_FAILED show=true
    fi

    ### the agent path be created
    if ! [[ -d $table_users/ ]]; then
        reply_msg res='error, users table not found, run db init first' \
            return=$ERR_EXPR_FAILED show=true
    fi

    if [[ -f $user_data_file ]]; then
        reply_msg res="error, user: $username already created" \
            return=$ERR_EXPR_FAILED show=true
    fi

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    declare -A server_info=()
    # rm -f $__tmp_path/${__fn_name}.txt
    # {
        # private::title ${args[silent]:-false} "id location username result"
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done
            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

            private::debug $LINENO "nc -tzv ${server_info['api_addr']} ${server_info['api_port']}";

            private::printf ${args[silent]:-false} "create $username"
            if [[ $(private::server_test) == false ]]; then
                private::print ${args[silent]:-false} "failure $ssm_api_addr"

                if [[ ${args[force]:-false} == false ]]; then
                    ### send notification to admins
                    # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-fetch-failed" | at now +1 minute > /dev/null 2>&1

                    reply_msg res="error, server=${server_info[location]} is down, force=false" return=$ERR_EXPR_FAILED show=true
                fi
            fi

            ### check if used already created or not
            if curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$username | jq --exit-status '.username=="'$username'"' > /dev/null 2>&1; then
                private::print ${args[silent]:-false} "existed [${server_info[location]}]";
                continue
            fi

            if [[ -f $user_data_file ]]; then
                old_password=$(jq '.uPSK' < $user_data_file)
                curl --silent --request POST --url http://${ssm_api_addr}/server/v1/users --data '{ "username": "'${username}'", "uPSK": '${old_password}' }'
                private::print ${args[silent]:-false} "readded [${server_info[location]}]";
            else
                curl --silent --request POST --url http://${ssm_api_addr}/server/v1/users --data '{ "username": "'${username}'", "uPSK": "'${password}'" }'
                private::print ${args[silent]:-false} "created [${server_info[location]}]";
            fi
        done 
    # } > $__tmp_path/${__fn_name}.txt 2>&1
    # column -t < $__tmp_path/${__fn_name}.txt

    private::debug $LINENO "server_info[@]: ${server_info[@]}";
    private::debug $LINENO "db_info[users]: $table_users";

    ### generate a static page for it
    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$username
    declare -r user_profile_index_html=$user_profile_path/index.html

    mkdir -p $user_profile_path
    rsync -az $dash_path/${agent_info[groupname]}.html $user_profile_index_html

    declare -r user_profile_page=${profile[link]}/${agent_info[groupname]}/$username
    declare -r user_qr_png=${profile_random}.png

    ### qr image
    perl -i -s -lpe 's/(?<=img src=").*?(?=" alt=)/$arg/' -- -arg=$user_qr_png $user_profile_index_html
    ### remote link
    # perl -i -s  -lpe 's/(?<=id="user-remote-link">).*?(?=<\/a>)/$arg/' -- -arg="$user_profile_page/profile" $user_profile_index_html
    perl -i -s -lpe 's/(?<=value=").*?(?=")/$arg/' -- -arg="$user_profile_page/$profile_random" $user_profile_index_html

    ### save the new user
    curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$username | \
    jq --exit-status "
        .realname=\"$user_realname\" |
        .ctime=(now|todate) |
        .day=$user_day |
        .gig=$user_gig |
        .page=\"$user_profile_page\/\" |
        .profile=\"$profile_random\" | del(.downlinkBytes,.uplinkBytes,.downlinkPackets,.uplinkPackets,.tcpSessions,.udpSessions)" | \
            sponge $user_data_file

    private::user_config aid=$agent_id user=$username method=local show=false $@
    private::user_config aid=$agent_id user=$username method=link show=false $@
    private::user_config aid=$agent_id user=$username method=link type=qr show=false $@

    jq::user_init user=$username | sponge $user_profile_path/${username}.json

    reply_msg res="page: <code>$user_profile_page/</code>" show=true \
    newline=true
}

private::user_delete(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r force=${args['force']:-false}
    declare -r select=${args['select']:-undefined}

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    
    if [[ -z $username ]]; then
        reply_msg res='error, user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    declare -A server_info=()
    # rm -f $__tmp_path/${fn_name}.txt
    # {
        # private::title ${args[silent]:-false} 'id location username result'
        # echo 'location username result'
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done
            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

            private::debug $LINENO "nc -tzv ${server_info['api_addr']} ${server_info['api_port']}";

            if [[ $username == all ]] && [[ $force == true ]]; then
                declare all_users=()
                case $select in
                    local )
                        ### all local users
                        mapfile -t all_users < <(ls -1 $table_users | sed 's/.json//g')
                    ;;
                    remote )
                        ### all remote users
                        mapfile -t all_users < <(curl --silent -X GET --url http://${ssm_api_addr}/server/v1/users | jq -r '.users[].username' | sort)
                    ;;
                    * )
                        reply_msg res="error, select=<local|remote> ?" show=true \
                            return $ERR_EXPR_FAILED
                            exit $ERR_EXPR_FAILED
                    ;;
                esac

                for user in ${all_users[@]}; do
                    private::printf ${args[silent]:-false} "delete $user"
                    curl --silent --request DELETE --url http://${ssm_api_addr}/server/v1/users/$user
                    private::print ${args[silent]:-false} "deleted [${server_info[location]}]"
                done
            else
                private::printf ${args[silent]:-false} "delete $username"
                ### check if used already created or not
                if curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$username | jq --exit-status '.username=="'$username'"' > /dev/null 2>&1; then
                    curl --silent --request DELETE --url http://${ssm_api_addr}/server/v1/users/$username 
                    private::print ${args[silent]:-false} "deleted [${server_info[location]}]"
                else
                    private::print ${args[silent]:-false} "noexist [${server_info[location]}]"
                fi
            fi
        done 
    # } > $__tmp_path/${fn_name}.txt 2>&1
    # column -t < $__tmp_path/${fn_name}.txt

    private::debug $LINENO "server_info[@]: ${server_info[@]}";

    reply_msg res=success show=${args[silent]:+true} ${@}
}

private::user_config(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r force=${args['force']:-false}
    declare -r profile_name=${args['pname']:-${args['pn']:-}}

    declare -r type=${args['type']:-json}
    declare -r method=${args['method']:-${args['met']:-${args['m']:-link}}}

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r table_configs=${db_info[root]}/${agent_info[groupname]}/${db_info[configs]}
    declare -r client_sample_file=$table_configs/client.sample.json
    declare -r user_data_file=${table_users}/${username}.json
    declare -r user_config_file=${table_configs}/${username}.json

    if [[ -z $username ]]; then
        reply_msg res='error, user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -d $table_configs/ ]]; then
        reply_msg res='error, configs table not found, run db init first' \
            return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error, user=$username not found" \
            return=$ERR_EXPR_FAILED show=true
    fi

    ### direct assignment because of args parser removing '='
    declare -r pass_ss=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass.ss' < $pool_servers_file )
    declare -r pass_tls=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass.tls' < $pool_servers_file )

    declare -r profile_random=$(jq -r '.profile' < $user_data_file)
    declare -r pass_user=$(jq -r '.uPSK' < $user_data_file)
    declare -r pass_user_final="${pass_ss}:${pass_user}"
    private::debug $LINENO "pass_user: $pass_user";
    private::debug $LINENO "pass_user_final: $pass_user_final";

    if ! [[ -f $client_sample_file ]]; then
        reply_msg res="error $client_sample_file not found" show=true \
            newline=true return=$ERR_EXPR_FAILED
    fi
     
    if [[ -f $user_config_file ]] &&
        [[ $force == false ]] &&
        [[ $method == local ]]; then
        reply_msg res="warning, ${username}.json config found, use force=true to update" show=true \
            return=$ERR_EXPR_FAILED
    fi

    if [[ $force == true ]] && [[ $method == local ]]; then
        mv $user_config_file ${user_config_file}.old
    fi

    if [[ $method == local ]]; then
    ### create the configuration file
        jq -c '
        (.outbounds[] | select(.type=="shadowsocks") | .password) = "'"$pass_user_final"'" |
        (.outbounds[] | select(.type=="shadowtls") | .password) = "'"${pass_tls}"'"
        ' < $client_sample_file > $user_config_file
    fi

    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r dash_link=${profile[link]}

    declare -r user_profile_page=${dash_link}/${agent_info[groupname]}/$username
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$username
    declare -r user_profile_file=$user_profile_path/$profile_random

    declare -r user_qr_png=${profile_random}.png
    declare -r user_url="${user_profile_page}/$profile_random#${profile_name:-$username}"

    if [[ $type == json ]]; then
        case $method in
            link )
                rsync -az $user_config_file $user_profile_file
                reply_msg res="link: <code>$user_profile_page/$profile_random</code>" \
                show=true $@
            ;;

            file )
                # private::telegram_doc user=$username file=$user_config_file
                echo "cd $PWD && ${0} tell doc user=$username aid=$agent_id file=$user_config_file" | at now +1 minute > /dev/null 2>&1

                reply_msg res="file: <code>${username}.json</code> is uploading ..." \
                show=true $@
            ;;

            local )
                reply_msg res="local: $user_config_file" \
                show=true $@
            ;;

            * )
                reply_msg res="unknown method: $method" show=true \
                    return=$ERR_EXPR_FAILED
            ;;
        esac
    fi

    if [[ $type == qr ]]; then
        case $method in
            link )
                rsync -az $user_config_file $user_profile_file
                echo "sing-box://import-remote-profile?url=$user_url" | \
                    qrencode -s 10 -t PNG -o ${user_profile_path}/$user_qr_png

                reply_msg res="link: <code>${user_profile_page}/$user_qr_png</code>" \
                show=true $@

            ;;
            file )
                echo "sing-box://import-remote-profile?url=$user_url" | \
                    qrencode -s 10 -t PNG -o ${user_config_file%.json}.png
                
                # private::telegram_doc user=$username file=${table_configs}/${username}.png
                echo "cd $PWD && ${0} tell doc user=$username aid=$agent_id file=${user_config_file%.json}.png" | at now +1 minute > /dev/null 2>&1

                reply_msg res="file: <code>${username}.png</code> is uploading ..." \
                show=true $@
            ;;
            * )
                reply_msg res="unknown method: $method, type: ${type}" show=true \
                    return=$ERR_EXPR_FAILED
            ;;
        esac
    fi

    # reply_msg res='create new one, rename old one' show=true newline=true ${@}
}

private::user_stat(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r caller=${args['caller']:-undefined}
    declare -r force=${args['force']:-false}

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    if [[ -z $username ]]; then
        reply_msg res='error, user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi
    
    if ! jq --exit-status '.users[] | select(.username=="'$username'")' $table_servers/*.json > /dev/null 2>&1; then
        case $caller in
            user_list )
                jq --null-input '{user: "??????????", bytes: "?", sessions: "?"}'
            ;;
            * )
                jq --null-input '{user: "'$username'", bytes: "?", sessions: "?"}'
            ;;
        esac
        reply_msg res="error, user=$username not found offline" return=$ERR_EXPR_FAILED show=true
    else
        # jq '.users | map({user: .username, bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
        #     jq '.[] | select(.user=="'$username'")' | \
        #     jq -s '{ user: (if .[0].user == null then "not-found-offline" else .[0].user end), bytes: (map(.bytes)|add), sessions: (map(.sessions)|add) }'

        case $caller in
            user_list | user_update )
                jq::user_stat
            ;;
            * )
                jq::user_stat | jq::table true
            ;;
        esac
    fi

    reply_msg res=success ${@}
}

private::user_bytes(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r force=${args['force']:-false}

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    if [[ -z $username ]]; then
        reply_msg res='error, user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! jq --exit-status '.users[] | select(.username=="'$username'")' $table_servers/*.json > /dev/null 2>&1; then
        echo 0;
        reply_msg res="error, user=$username not found" return=$ERR_EXPR_FAILED show=true
    else
        jq '.users | map({user: .username, bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
            jq '.[] | select(.user=="'$username'")' | \
            jq -rs '(map(.bytes)|add) '
    fi

    reply_msg res=success ${@}
}

private::user_notif(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}
    declare -r notif_msg=${args['notif']:-${args['msg']:-${args['m']:-}}}
    declare -r archive=${args[archive]:-false}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}

if [[ -z $username ]]; then
    echo "[X] error: user=<string>"
    exit 1
fi

if [[ -z $notif_msg ]]; then
    echo "[X] error: msg=<string>"
    exit 1
fi

    private::user_get "$@" | \
    yq '.user=("<code>" + .user + "</code>")' | \
    private::telegram_msg aid=$agent_id

    ### if a user file is a symbolic link, remove it
    if [[ -L ${table_bytes}/${username}.json ]]; then
        rm -f ${table_bytes}/${username}.json
    fi

    reply_msg res=success ${@}
}

private::user_init(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    ### the agent path be created
    if ! [[ -d $table_bytes/ ]]; then
        reply_msg res='error, users table not found, run db init first' return=$ERR_EXPR_FAILED show=true
    fi

    ### find connected users
    # [inefficient]  mapfile -t local_users < <(ls -1 $table_users | sed 's/.json//g')
    mapfile -t online_users < <(jq -r '.users[] | .username' $table_servers/*.json | sort | uniq)
    for user in ${online_users[@]}; do
        declare -i user_bytes=$(private::user_bytes user=$user)
        if (( user_bytes == 0 )); then
            continue
        else
            if [ -f $table_bytes/${user}.json ]; then
                private::printf ${args[silent]:-false} "update user=$user"
                jq::user_update $@
            else
                private::printf ${args[silent]:-false} "init user=$user"
                jq::user_init user=$user | \
                sponge $table_bytes/${user}.json
                echo "init-ed"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg=user-init " | at now +1 minute > /dev/null 2>&1
            fi
        fi
    done

    reply_msg res=success ${@}
}

private::user_fetch(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r user_bytes_file=$table_bytes/${username}.json

    if [[ -z $username ]]; then
        reply_msg res='error: user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="error: user=$username not found" return=$ERR_FILE_NOT_FOUND show=true
    fi

    yq -p json -o yaml '.' $table_bytes/${username}.json

    reply_msg res=success ${@}
}
private::user_get(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}
    declare -r notif_msg=${args['notif']:-${args['msg']:-${args['m']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_archive=${db_info[root]}/${agent_info[groupname]}/${db_info[archive]}
    declare -r user_bytes_file=$table_bytes/${username}.json
    declare -r server_name=$(hostname)

    if [[ -z $username ]]; then
        reply_msg res='error: user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="error: user=$username not found" return=$ERR_EXPR_FAILED show=true
    fi

jq '
(1024 * 1024 * 1024) as $one_gig |
(1024 * 1024) as $one_meg |
(24 * 60 * 60) as $one_day |
(if ((.bytes.used/$one_gig)|floor) == 0 then ((.bytes.used/$one_meg|floor|tostring)+"M") else ((.bytes.used/$one_gig|floor|tostring)+"G") end) as $traffic_used |
(if ((.bytes.pday/$one_gig)|floor) == 0 then ((.bytes.pday/$one_meg|floor|tostring)+"M") else ((.bytes.pday/$one_gig|floor|tostring)+"G") end) as $traffic_pday |

{
  user: .user,
  sessions: .sessions,
  ctime: (.ctime|todate),
  atime: (.atime|todate),
  etime: (.etime|todate),
  traffics: {
    base: (((.bytes.base/$one_gig)|tostring) + "G"),
    used: $traffic_used,
    pday: $traffic_pday,
    limit: false
  },
  days: {
    base: (.seconds.base/$one_day),
    used: (.seconds.used/$one_day)|floor,
    limit: false
  },
  server: {
    app: "sing-box",
    msg: "'"${notif_msg}"'",
    host: "'$server_name'"
  }
}' < $user_bytes_file | \
yq -p json -o yaml

    reply_msg res=success ${@}
}

private::user_list(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    private::debug $LINENO "args: ${@}";

    declare -r data_int=$(private::data_int bool)
    if [[ $data_int == false ]]; then
        reply_msg res='error, data integrity failure' \
        show=true return=$ERR_EXPR_FAILED
    fi

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    declare -r random_serve_id=$((RANDOM % ${#server_ids[@]}))

    for sid in "${server_ids[$random_serve_id]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        declare -A server_info=()
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done

        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
        mapfile -t users < <(curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | jq -r '.users[] | .username')
        for user in ${users[@]}; do
            private::user_stat user=$user caller=$fn_name
        done | jq::table true
    done

    reply_msg res="success, NOTE users query server-id: ${random_serve_id}" \
    show=true newline=yes $@
}
private::user_archive(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_archive=${db_info[root]}/${agent_info[groupname]}/${db_info[archive]}
    declare -r user_bytes_file=$table_bytes/${username}.json

    if [[ -z $username ]]; then
        reply_msg res='error: user=<string> ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="error: user=$username not found" return=$ERR_FILE_NOT_FOUND show=true
    fi

    declare -ir time_in_sec=$(date +%s)
    declare -r archive_path=$(date +%Y/%m/%d)

    mkdir -p $table_archive/$archive_path
    declare -r old_user_bytes_file=$table_archive/$archive_path/${username}.json
    declare -r archive_relative_path=../${db_info[archive]}/$archive_path/${username}.json

    if [[ -f $old_user_bytes_file ]]; then
        mv $old_user_bytes_file ${old_user_bytes_file}.${time_in_sec}
    fi

    mv -f $table_bytes/${username}.json $old_user_bytes_file
    ln -fs  $archive_relative_path -t $table_bytes/

    reply_msg res=success $@
}

private::user_limit(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    # declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    # declare -r user_bytes_file=$table_bytes/${username}.json

    # if [[ -z $username ]]; then
    #     reply_msg res='error: user=<string> ?' return=$ERR_EXPR_FAILED show=true
    # fi

    # if ! [[ -f $user_bytes_file ]]; then
    #     reply_msg res="error: user=$username not found" return=$ERR_FILE_NOT_FOUND show=true
    # fi

    
    mapfile -t online_users < <(jq -r '.users[] | .username' $table_servers/*.json | sort | uniq)
    for user in ${online_users[@]}; do
        declare -i user_bytes=$(private::user_bytes user=$user)
        if (( user_bytes == 0 )); then
            continue
        else
            private::printf ${args[silent]:-false} "limit user=$user"
            
            ### traffic check
            bytes_used=$(jq '.bytes.used >= .bytes.base' < $table_bytes/${user}.json)
            if [[ $bytes_used == true ]]; then
                declare -r msg="traffic-finished, deleting user"
                private::info ${args[silent]:-false} "$msg ... "

                private::user_delete  user=$user silent=true
                private::user_archive user=$user silent=true
                private::server_fetch silent=true

                private::info ${args[silent]:-false} "done\n"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1

                continue
            fi

            bytes_in24=$(jq '.bytes.used >= (.bytes.base - 1e9)' < $table_bytes/${user}.json)
            if [[ $bytes_in24 == true ]]; then
                declare -r msg="traffic-limiting in 24h"
                bytes_limit=$(jq '.bytes.limit' < $table_bytes/${user}.json)
                if [[ $bytes_limit == false ]]; then
                    private::info ${args[silent]:-false} "$msg\n"
                    jq '.bytes.limit=true' < $table_bytes/${user}.json | \
                    sponge $table_bytes/${user}.json

                    ### notify
                    echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1
                else 
                    private::info ${args[silent]:-false} "has been notifid, $msg\n"
                fi
                continue
            fi

            ### expiration check
            seconds_used=$(jq '.seconds.used >= .seconds.base' < $table_bytes/${user}.json)
            if [[ $seconds_used == true ]]; then
                declare -r msg="date-expired, deleting user"
                private::info ${args[silent]:-false} "$msg ... "

                private::user_delete  user=$user silent=true
                private::user_archive user=$user silent=true
                private::server_fetch silent=true

                private::info ${args[silent]:-false} "done\n"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1

                continue
            fi

            seconds_in24=$(jq '.seconds.used >= (.seconds.base - (24 * 60 * 60))' < $table_bytes/${user}.json)
            if [[ $seconds_in24 == true ]]; then
                declare -r msg='date-expiring in 24h'
                seconds_limit=$(jq '.seconds.limit' < $table_bytes/${user}.json)
                if [[ $seconds_limit == false ]]; then
                    private::info ${args[silent]:-false} "$msg\n"
                    jq '.seconds.limit=true' < $table_bytes/${user}.json | \
                    sponge $table_bytes/${user}.json

                    ### notify
                    echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1
                else
                    private::info ${args[silent]:-false} "has been notifid, $msg\n"
                fi
                continue
            fi

            private::print ${args[silent]:-false} "ignored"
        fi

    done

    reply_msg res=success $@
}


public::user(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(create delete config stat bytes init fetch get list notif archive limit print);

    __action_list[create]='create a new user'
    __action_list[delete]='delete a user'
    __action_list[config]='get an app configuration';
    __action_list[stat]='stat of a user';
    __action_list[bytes]='sum of bytes of a user';
    __action_list[init]='initialize a user';
    __action_list[fetch]='fetch a user data';
    __action_list[get]='get a user data';
    __action_list[list]='list all users with total bytes';
    __action_list[notif]='notify a user';
    __action_list[archive]='archive a user';
    __action_list[limit]='limit a user';
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${server_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value
    # declare -A db_info=()
    # mapfile -t tmp < <(yq ".db" $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";


    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        create | delete | config | stat | bytes | init | fetch | get | list | notif | archive | limit )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="$__fn_name $__action, not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}


################################################################################
# server command
################################################################################
private::server_check(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    private::debug $LINENO "args: ${@}";

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -a server_ids=()

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    {
        # private::title ${args[silent]:-false} "id location address status"
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done
            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            
            private::printf ${args[silent]:-false} "check server=${server_info[location]}"

            declare fetched=$(private::server_test)
            if [[ $(private::server_test) == true ]]; then
                private::print ${args[silent]:-false} "checked"
            fi

            if [[ $(private::server_test) == false ]]; then
                private::print ${args[silent]:-false} "failure $ssm_api_addr"

                if [[ ${args[force]:-false} == false ]]; then
                    ### send notification to admins
                    # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-fetch-failed" | at now +1 minute > /dev/null 2>&1
                    echo "date > /tmp/date.txt" |& at now +1 minute > /dev/null 2>&1

                    reply_msg res="error, server=${server_info[location]} is down, force=false" return=$ERR_EXPR_FAILED show=true
                fi
            fi



            # # private::print ${args[silent]:-false} "${server_info[id]} ${server_info[location]} ${server_info[api_addr]} "
            # if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
            #     curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
            #     private::print ${args[silent]:-false} "checked"
            # else
            #     private::print ${args[silent]:-false} "failure: ${ssm_api_addr}, admin be will notified ..."


            #     if [[ ${args[force]:-false} == false ]]; then
            #         ### send notification to admins
            #         # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-is-down" | at now +1 minute > /dev/null 2>&1

            #         reply_msg res="error, server=${server_info[location]} is down, force=false" return=$ERR_EXPR_FAILED show=true
            #     fi
            # fi
        done
    } # | column -t

    reply_msg res=success ${@}
}

private::server_list(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    private::debug $LINENO "args: ${@}";

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### jq solution
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    jq  '{ id: .server_id, location: .server_loc, ssm_api: .ssm_api, users: (.users | length) }' $table_servers/*.json | \
    jq::table true

    ### bash solution
    # mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    # {
    #     echo id location address port
    #     for sid in "${server_ids[@]}"; do
    #         mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
    #         declare -A server_info=()
    #         for line in "${props[@]}"; do
    #             IFS=\ =\  read key value <<< "$line"
    #             server_info[$key]="$value";
    #         done

    #         echo ${server_info[id]} ${server_info[location]} ${server_info[api_addr]} ${server_info[api_port]}
    #     done
    # } | column -t

    reply_msg res=success $@
}

private::server_fetch(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    private::debug $LINENO "args: ${@}";

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    ### check servers are up/down
    ### can cause some bugs, find a better solution
    ### probably a single server_check function to check every server well called
    # private::server_check silent=true force=${args[force]:-false}

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    {
        # private::title ${args[silent]:-false} "id location address result"
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            api_addr_json_file=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}/${server_info[api_addr]}.json

            private::printf false "fetch server=${server_info[location]}"

            declare fetched=$(private::server_test)
            if [[ $(private::server_test) == true ]]; then
                curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | \
                    jq '.server_id = '$sid' | .ssm_api = "'$ssm_api_addr'" | .server_loc = "'${server_info[location]}'"' | \
                    sponge $api_addr_json_file 2>&1
                private::print ${args[silent]:-false} "fetched"
            fi

            if [[ $(private::server_test) == false ]]; then
                private::print ${args[silent]:-false} "failure $ssm_api_addr"

                if [[ ${args[force]:-false} == false ]]; then
                    ### send notification to admins
                    # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-fetch-failed" | at now +1 minute > /dev/null 2>&1
                    echo "date > /tmp/date.txt" |& at now +1 minute > /dev/null 2>&1

                    reply_msg res="error, server=${server_info[location]} is down, force=false" return=$ERR_EXPR_FAILED show=true
                fi
            fi
        done
    } # |  column -t

    reply_msg res=success $@
}

private::server_stat(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    private::debug $LINENO "args: ${@}";

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r query=${args['query']:-offline}
    declare -r table=${args['table']:-true}

    declare -i server_id=${args['sid']:--1}
    declare -a server_ids=()

    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)

    if (( $server_id != -1 )); then
        server_ids=($server_id)
        # declare -r yq_server_id=$((server_id - 1))

        ### NOTE
        ### yq can match negative index for an array, e.g. -1 matches last index
        if ! yq --exit-status ".servers[$(($server_id-1))].id" $pool_servers_file > /dev/null 2>&1; then
            reply_msg res="error server-id $server_id not found" show=true \
            return=$ERR_EXPR_FAILED
        fi
    fi

    if [[ $query == offline ]]; then
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            api_addr_json_file=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}/${server_info[api_addr]}.json

            if ! [[ -f $api_addr_json_file ]]; then
                reply_msg res="error, data for ${server_info[api_addr]} not found" \
                    return=$ERR_FILE_NOT_FOUND show=true
            fi

            declare -i count=$(jq '.users | length' < $api_addr_json_file)
            private::title ${args[silent]:-false} "location=${server_info[location]}, users=$count, query=offline"

            if (( count == 0 )); then
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            else
                jq < $api_addr_json_file | \
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            fi

            if [[ $sid != ${server_ids[${#server_ids[@]}-1]} ]]; then
                echo
            fi
        done
    elif [[ $query == online ]]; then
        ### all server should be up
        private::server_check silent=true

        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            declare -i count=$(curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | jq '.users | length')
            # echo online[${server_info[location]}] users[$count]
            private::title ${args[silent]:-false} "location=${server_info[location]}, users=$count, query=online"

            if (( count == 0 )); then
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            else
                curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | \
                jq '.server_id = '$sid' | .ssm_api = "'$ssm_api_addr'" | .server_loc = "'${server_info[location]}'"' | \
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            fi

            if [[ $sid != ${server_ids[${#server_ids[@]}-1]} ]]; then
                echo
            fi
        done
    fi

    reply_msg res=success ${@}
}

private::server_test(){
    if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
        curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
        printf "true\n";
    else
        printf "false\n";

        ### send notification to admins
        # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-is-down" | at now +1 minute > /dev/null 2>&1
    fi
}

public::server(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(check list fetch stat print);

    __action_list[check]='check if servers are up/down'
    __action_list[list]='list of servers'
    __action_list[fetch]='fetch servers data'
    __action_list[stat]='stat servers data'
    __action_list[print]='print info'

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi

    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
        # reply_msg res="agent not found" retun=$ERR_EXPR_FAILED
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done


    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${server_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value
    # declare -A db_info=()
    # mapfile -t tmp < <(yq ".db" $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";
    
    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;

        check | list | fetch | stat )
            private::${__fn_name}_${__action} "$@";
        ;;

        * )
            reply_msg res="error, action $__action not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}

################################################################################
# agent command
################################################################################
private::agent_pool(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r new_pool_id=${args['pid']:-}
    declare -r active_pool_id=${new_pool_id:-${agent_info[pool_id]}}

    ### update the file
    if [[ $active_pool_id == ${agent_info[pool_id]} ]]; then
        yq --exit-status ".pools" $agent_config_file | yq::table true

        reply_msg res="current pool-id: ${active_pool_id}" show=true newline=true
        exit $EXIT_SUCCESS
    fi

    if [[ -n $new_pool_id ]]; then
        private::debug $LINENO new_pool_id: $new_pool_id
        private::debug $LINENO agent_config_file: $agent_config_file

        ### check for access
        if ! yq --exit-status ".pools[] | select(.id==$new_pool_id)" $agent_config_file > /dev/null 2>&1; then
            reply_msg res="error, pool-id: ${new_pool_id} not found" show=true return=$ERR_EXPR_FAILED $@
        fi

        yq --exit-status -i '.agent.pool_id='${new_pool_id}'' $agent_config_file
        yq --exit-status -o json  ".pools[] | select(.id==${active_pool_id})" \
            $agent_config_file | jq::table true
    fi

    reply_msg res="set new pool-id: ${active_pool_id}" show=true newline=true $@
}

private::agent_server(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;
    
    declare -r new_pool_id=${args['pid']:-}
    declare -r active_pool_id=${new_pool_id:-${agent_info[pool_id]}}

    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml
    private::debug $LINENO pool_servers_file: $pool_servers_file

    ### update the file
    if [[ $active_pool_id == ${agent_info[pool_id]} ]]; then
        if ! [[ -f $pool_servers_file ]]; then
            reply_msg res="error pool-id file ${agent_pool_id}.yaml not found" show=true return=$ERR_EXPR_FAILED
        fi

        yq --exit-status '.servers' $pool_servers_file | \
            yq::table true
            # yq -r  '. as $R | ($R[0] | to_entries | map(.key) | join(" ")) as $H | ($H, $R[] | to_entries | map(.value) | join(" "))'

        reply_msg res=success show=true newline=true $@
    else
        reply_msg res="current pool-id is NOT: ${active_pool_id}" show=true
        exit $EXIT_SUCCESS
    fi
}


public::agent(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(pool server print);

    __action_list[pool]='list of pools or select a pool'
    __action_list[server]='list of servers'
    __action_list[print]='print info'

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    # yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    # ### map key and value for pool_info
    # mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     pool_info[$key]="$value";
    # done
    # private::debug $LINENO "pool_info: ${pool_info[@]}";
    # private::debug $LINENO "agent_pool_id: $agent_pool_id";

    # declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value for db_info
    # declare -A db_info=()
    # db_info[name]=${agent_info[groupname]}
    # db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    # mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        pool | server )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="$__fn_name $__action, not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}


################################################################################
# db
################################################################################
private::data_setup(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### table initialization
    mapfile -t table_list < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables[]' $pool_servers_file)
    for table in ${table_list[@]}; do
        echo create: ${db_info[root]}/${agent_info[groupname]}/$table
        mkdir -p ${db_info[root]}/${agent_info[groupname]}/$table
    done

    reply_msg res=success ${@}
}

private::data_info(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### table initialization
    yq '.db.info[] | select(.name=="'${agent_info[groupname]}'")' $pool_servers_file

    reply_msg res=success ${@}
}

private::data_test(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r query=${args[query]:-offline}

    echo "#### $(date '+%F-%A-%T') ####"

    if [[ $query == online ]]; then
        ### fetch data from servers
        private::server_fetch aid=$agent_id
    fi

    private::title false "\ndata tests"
    private::printf false "user integrity"
    private::data_int string


    reply_msg res=success ${@}
}

private::data_int(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -r type=${1:-string}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    case $type in
        boolean | bool | b )
            jq '.users | length' ${table_servers}/*.json | jq -rs '(max == min)'
        ;;
        string | str | s )
            jq '.users | length' ${table_servers}/*.json | jq -rs 'if (max == min) then "passed" else "failure" + " min:" + (min|tostring) + " max:" + (max|tostring) end'
        ;;
        * )
            echo type=$type
        ;;
    esac
}

private::data_sync(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r data_int=$(private::data_int bool)
    if [[ $data_int == true ]]; then
        reply_msg res='error, data integrity test passed' \
        show=true return=$ERR_EXPR_FAILED
    fi

    declare -r source=${args['source']:-${args['src']:-${args['s']:-undefined}}}
    if [[ $source == undefined ]]; then
        reply_msg res='error source=<string> ?' show=true return=$ERR_EXPR_FAILED
    fi

    # declare -r target=${args['target']:-${args['tar']:-${args['t']:-undefined}}}
    # if [[ $target == undefined ]]; then
    #     reply_msg res='error target=<string> ?' show=true return=$ERR_EXPR_FAILED
    # fi


    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    mapfile -t source_users < <(jq -r  'select(.server_loc=="'$source'") | .users[] | .username' $table_servers/*.json)
    if (( ${#source_users[@]} ==  0 )); then
        reply_msg res="error source=$source not found, try: server list" \
            show=true return=$ERR_EXPR_FAILED
    fi

    for user in ${source_users[@]}; do
        private::printf false "sync.$user"
        private::user_create user=$user silent=true
        private::print false "syncing"

    done

    reply_msg res=success ${@}
}

################################################################################
# db command
################################################################################
public::data(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(setup info test sync print);

    __action_list[setup]='setup a db'
    __action_list[info]='info of a db';
    __action_list[test]='sync a db'
    __action_list[sync]='sync a db'
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
 
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        setup | info | test | sync )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="$__fn_name $__action, not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}


################################################################################
# telegram command
################################################################################
private::telegram_msg(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    # declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    # declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    # declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";


    ### check api.telegram.org access
    if ! nc -w3 -tzv  api.telegram.org 443 > /dev/null 2>&1; then
        reply_msg res='no access to api.telegram.org:443' \
        return=$ERR_EXPR_FAILED show=true newline=true
    fi

    declare -r username=${args['user']:-nobody}
    declare -r user_msg=${args['msg']:-}
    declare -r chat_id=${args['chid']:-}

    if [[ -p /dev/stdin ]]; then
        stdin_msg="$(< /dev/stdin)"
    else
        if [[ -z $user_msg ]]; then
            reply_msg res="error, msg=<string> ?" return=$ERR_EXPR_FAILED show=true
        fi
    fi

    declare -r date_now=$(date +%F-%A-%T)
    declare -r table_notifs=${db_info[root]}/${agent_info[groupname]}/${db_info[notifs]}

    declare -r bot_text="${user_msg:-$stdin_msg}"
    declare -r bot_token="${agent_info[bot_token]}"
    declare -r bot_chat_id=${chat_id:-"${agent_info[bot_chat_id]}"}
    declare -r bot_log_file=$table_notifs/${0%.sh}.json

    ### sendDocument -- https://core.telegram.org/bots/api#sendMessage
    curl -sL  \
        --retry 3 \
        --max-time 3 \
        --connect-timeout 3 \
        -o $bot_log_file \
        -F text="$bot_text" \
        -F chat_id="$bot_chat_id" \
        -F parse_mode="HTML" \
        -X POST \
        https://api.telegram.org/bot$bot_token/sendMessage

    ### validate the result
    declare -r send_doc_result=$(jq '.ok' < $bot_log_file)
    if [[ $send_doc_result == 'true' ]]; then
        echo "msg $date_now '$bot_text'" | tee -a $table_notifs/${username}.txt
    else
        declare error_description=$(jq '.description' < $bot_log_file)
        echo "msg $date_now error: $error_description" |& tee -a $table_notifs/${username}.txt
        exit 1
    fi

    reply_msg res=success $@
}

private::telegram_doc(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";


    ### check api.telegram.org access
    if ! nc -w3 -tzv  api.telegram.org 443 > /dev/null 2>&1; then
        reply_msg res='no access to api.telegram.org:443' \
        return=$ERR_EXPR_FAILED show=true newline=true
    fi

    declare -r username=${args['user']:-nobody}
    declare -r user_file=${args['file']:-}
    declare -r user_caption=${args['cap']:-}
    declare -r chat_id=${args['chid']:-}

    if ! [[ -f $user_file ]]; then
        reply_msg res="error, file=<file> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r date_now=$(date +%F-%A-%T)
    declare -r table_notifs=${db_info[root]}/${agent_info[groupname]}/${db_info[notifs]}

    declare -r bot_token="${agent_info[bot_token]}"
    declare -r bot_chat_id=${chat_id:-"${agent_info[bot_chat_id]}"}
    declare -r bot_log_file=$table_notifs/${0%.sh}.json

    ### sendDocument -- https://core.telegram.org/bots/api#senddocument
    curl -sL  \
        --retry 3 \
        --max-time 3 \
        --connect-timeout 3 \
        -o $bot_log_file \
        -F document=@"$user_file" \
        -F chat_id="$bot_chat_id" \
        -F parse_mode="HTML" \
        -F caption="$user_caption" \
        -X POST \
        https://api.telegram.org/bot$bot_token/sendDocument

    ### validate the result
    declare -r send_doc_result=$(jq '.ok' < $bot_log_file)
    if [[ $send_doc_result == 'true' ]]; then
        echo "doc $date_now '$user_file'" | tee -a $table_notifs/${username}.txt
    else
        declare -r error_description=$(jq '.description' < $bot_log_file)
        echo "doc $date_now error: $error_description" |& tee -a $table_notifs/${username}.txt
        reply_msg res='error, see the notif log' $@
    fi

    reply_msg res=success show=true newline=true $@
}

private::telegram_test(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";

    private::telegram_msg msg="telegram test message from ${0} by ${agent_info[groupname]}" \
        user=${agent_info[groupname]}

    reply_msg res=success $@
}


public::telegram(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(msg doc test print);

    __action_list[msg]='send a message/text'
    __action_list[doc]='send a document/file';
    __action_list[test]='test a notification'
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        msg | doc | test  )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="$__fn_name $__action, not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}


################################################################################
# app command
################################################################################
private::app_test_cmd() {
    declare -a cmds=(printf echo mkdir jq yq qrencode rsync nc);

    for cmd in ${cmds[@]}; do
        if which $cmd > /dev/null 2>&1; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$cmd~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$cmd~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $cmd in
                yq )
                    echo "Install $cmd from here: https://github.com/mikefarah/yq";
                    exit $ERR_EXPR_FAILED
                ;;
                jq )
                    echo "Install $cmd from here: https://stedolan.github.io/jq/";
                    exit $ERR_EXPR_FAILED
                ;;
                printf | echo | qrencode | rsync )
                    echo "Install $cmd with your package manager";
                    exit $ERR_EXPR_FAILED
                ;;
                nc )
                    echo "Install netcat-openbsd with your package manager";
                    exit $ERR_EXPR_FAILED
                ;;
                * )
                    echo "no source found for: $cmd";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_dir() {
    declare -a dirs=(.prox/agent .prox/pool .prox/log .prox/tmp);

    for dir in ${dirs[@]}; do
        if [[ -d $dir ]]; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$dir~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$dir~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $dir in
                * )
                    echo "please mkdir $dir";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_file() {
    for ff in ${@}; do
        if [[ -f $ff ]]; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$ff~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$ff~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $ff in
                server.sample.json )
                    echo "$ff is optional on AAA server";
                ;;
                * )
                    echo "please add/configure $ff";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_server() {
    mapfile -t server_ids < <(yq ".servers[].id" $pool_servers_file --output-format props)
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        declare -A server_info=()
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done

        printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "server=${server_info[location]}~" "~" | tr ' ~' '. ';
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
        if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
            curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
            printf "passed\n";
        else
            printf "failed, ${ssm_api_addr}\n";
            exit $ERR_EXPR_FAILED
        fi
    done
}

private::app_test(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    # declare -r client_sample_file=${db_info[root]}/${agent_info[groupname]}/${db_info[configs]}/client.sample.json
    declare -r client_sample_file=client.sample.json
    declare -r server_sample_file=server.sample.json
    private::title false "commands test:"
    private::app_test_cmd
    
    private::title false "\ndirectories test:"
    private::app_test_dir

    private::title false "\nfiles test:"
    private::app_test_file $agent_config_file $pool_servers_file \
        $client_sample_file \
        server.sample.json

    private::title false "\nservers test:"
    private::app_test_server

    reply_msg res=success show=true newline=true $@
}

private::app_init(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::info false "user app tests\n\n"
    private::app_test show=false

    private::title false "\nsetup database:"
    private::data_setup

    private::title false "\ncreate a user (user=prox):"
    private::user_create user=prox
    
    private::title false "\nconfigure a user [user=prox force=true]:"
    private::user_config user=prox force=true

    reply_msg res=success ${@}
}

private::app_run(){
    declare -r fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r background=${args['back']:-${args['bg']:-${args['b']:-false}}}
    declare -r background_type=${args['type']:-prerun}
    declare -ir period=${args['period']:-${args['p']:-5}}

    if [[ $background == true ]] && [[ $background_type == prerun ]]; then
        echo "background: ${0} ${fn_name/_/ } aid=$agent_id bg=true (in +${period} minute)"
        echo "cd $PWD && ${0} ${fn_name/_/ } aid=$agent_id bg=true period=$period type=postrun" | at now +${period} minute > /dev/null 2>&1
        exit $EXIT_SUCCESS
    fi

{
    ### fetch data from servers
    echo "#### $(date '+%F-%A-%T') ####"

    private::server_check aid=$agent_id $@
    echo

    private::server_fetch aid=$agent_id $@
    echo

    ### check user init or update
    private::user_init aid=$agent_id $@
    echo

    ### check user limits
    private::user_limit aid=$agent_id $@
} | tee -a $__log_path/$fn_name.txt


    if [[ $background == true ]] && [[ $background_type == postrun ]]; then
        echo "cd $PWD && ${0} ${fn_name/_/ } aid=$agent_id bg=true period=$period type=postrun" | at now +${period} minute > /dev/null 2>&1
    fi

    reply_msg res=success ${@}
}

public::app(){
    declare -r __fn_name=${FUNCNAME##*:};
    private::debug $LINENO $FUNCNAME ;

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(test init run print);

    __action_list[test]='test dependencies'
    __action_list[init]='initialize the app'
    __action_list[run]='run the app'
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=<number> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED show=true
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        init | test | run )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="$__fn_name $__action, not found" return=$ERR_EXPR_FAILED show=true
        ;;
    esac
}


################################################################################
# help and parse functions
################################################################################
private::cli_install(){
    if which $CLI_NAME > /dev/null 2>&1 ; then
        md5sum ./$CLI_NAME
        md5sum $CLI_INSTALL_PATH/$CLI_NAME;
        read -p "Already $CLI_NAME has been installed, want to overwrite [y/n]? " user_choice;
        case $user_choice in
            y )
                sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
                which $CLI_NAME;
            ;;
            * )
                printf "installing $0 cancelled\n";
                exit $EXIT_SUCCESS;

            ;;
        esac
    else
        sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
        which $CLI_NAME;
    fi

    exit $?;
}

private::cli_version(){
    printf "%s %s\n" $CLI_NAME $CLI_VERSION;
    printf "%s\n" $CLI_SOURCE_LINK;
    exit $EXIT_SUCCESS;
}

private::debug(){
    if [[ $SCRIPT_DEBUG_FLAG == true ]]; then
        printf "\033[1;33m${0} ($1) [${*:2}]\033[0m\n" 1>&2; 
    fi
}

private::debug_full(){
    set -x;
}

public::help(){
    printf "$ANSISHELL_HEADER";
    private::debug $LINENO $FUNCNAME ;

    printf "\n\nusage:\n";
    printf "$CLI_NAME [--options]\n";
    printf "$CLI_NAME [--options] command <subcommand> [arg=<arg>, ...]\n";

    printf "\noptions:\n";
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-h  | --help' 'show this help menu';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-v  | --version' 'show version';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-d  | --debug' 'enable debugging (script level)';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-D  | --DEBUG' 'enable bash debugging (bash level)';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-t  | --trap' 'enable trap for errors';

    printf "\ncommands:\n";
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'app    [a]' 'manage the app';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'server [s]' 'manage servers';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'agent  [ag]' 'manage agents';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'user   [u]' 'manage users';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'data   [d]' 'manage databases';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'tell   [t]' 'manage notifications (telegram) ';

    exit ${1:-1};
}

private::parse_options(){
    if (( ${#} == 0 )); then
        public::help 0;
    fi

    case $1 in
        -h | --help | help )
            public::help 0;
        ;;
        -d | --debug )
            SCRIPT_DEBUG_FLAG=true
            shift;
        ;;
        -D | --DEBUG )
            private::debug_full;
            shift;
        ;;
        -t | --trap )
            trap '__error_handing__ $? $LINENO' ERR
            shift;
        ;;
        -v | --version | version )
            private::cli_version;
            shift;
        ;;
    esac

    if (( ${#} != 0 )); then
        case ${1} in
            h | help | \
            a | app | \
            u | usr | user  | \
            s | srv | serv | server | \
            ag | agent | \
            d | db | data | \
            t | tell | telegram )
                private::debug $LINENO continue-main: "'$@'";
                private::main "$@";
            ;;
            * )
                printf "command: '%s' not found\n" $1;
                exit $ERR_EXPR_FAILED;
            ;;
        esac
    fi
}

################################################################################
# main function
################################################################################
private::main(){
    if (( ${#} == 0 )); then
        public::help 0;
    fi

    case ${1} in
        h | help | \
        a | app | \
        u | usr | user  | \
        s | srv | serv | server | \
        ag | agent | \
        d | db | data | \
        t | tell | telegram )
            private::debug $LINENO 'command:' "'${1}'";
            private::debug $LINENO 'command-options:' "'${@:2}'";
            public::${main_cmds[$1]} "${@:2}";
        ;;
        * )
            private::parse_options "$@";
        ;;
    esac
}

private::main "$@";
