#!/bin/bash
#
#
# full AAA wrapper for shadowsocks in sing-box
# frontend: Bash
# backend: sing-box proxy v1.12 and upper
#
# Shakiba Moshiri (C) 20XX


################################################################################
# bash strict mode
################################################################################
private::strict_mode(){
    set -T # inherit DEBUG and RETURN trap for functions
    set -C # prevent file overwrite by > &> <>
    set -E # inherit -e
    set -e # exit immediately on errors
    set -u # exit on not assigned variables
    set -o pipefail # exit on pipe failure
    shopt -s extglob
}
private::strict_mode;

################################################################################
# handle debugging
################################################################################
function __error_handing__(){
    local last_status_code=$1;
    local error_line_number=$2;
    echo 1>&2 "Error - exited with status $last_status_code at line $error_line_number";
    perl -slne 'if($.+5 >= $ln && $.-4 <= $ln){ $_="$. $_"; s/$ln/">" x length($ln)/eg; s/^\D+.*?$/$&/g;  print}' -- -ln=$error_line_number $0
    echo;
}

# function __debug_handing__() {
#     echo "DEBUG [${BASH_COMMAND[0]}] [$?]"
#     sleep 0.1
# }

# function __exit_handing__(){
#     printf '\n%s\n' ${FUNCNAME}
# }

# trap '__error_handing__ $? $LINENO' ERR
# trap '__exit_handing__ $?' INT TERM EXIT
# trap '__debug_handing__ $? $LINENO' DEBUG


### immutable variables
declare -ir ERR_EXPR_FAILED=1;
declare -ir ERR_FILE_NOT_FOUND=2;
declare -ir ERR_OPTION_NOT_FOUND=3;
declare -ir ERR_EXIT_IMD=4;
declare -ir EXIT_SUCCESS=0;
declare -ir CLI_PPID=$$;

declare -r PS4='debug($LINENO) ${FUNCNAME[0]:+${FUNCNAME[0]}}(): ';
declare -r CLI_NAME='prox';
declare -r CLI_VERSION='0.10.0';
declare -r CLI_SOURCE_LINK='https://github.com/shakibamoshiri/prox';
declare -r CLI_INSTALL_PATH='/usr/local/bin';
declare -r PRINTF_HELP_OFFSET=20;
declare -r PRINTF_APP_TEST_OFFSET=30;

declare -r ANSISHELL_HEADER="full AAA wrapper for shadowsocks in sing-box";

declare -rA main_cmds=(
    [h]=help
    [help]=help

    [a]=app
    [app]=app

    [u]=user
    [usr]=user
    [user]=user

    [s]=server
    [srv]=server
    [serv]=server
    [server]=server

    [ag]=agent
    [agent]=agent

    [d]=data
    [db]=data
    [data]=data

    [t]=telegram
    [tell]=telegram
    [telegram]=telegram
)

declare SCRIPT_DEBUG_FLAG=false


################################################################################
# app configuration
################################################################################
declare -r __pool_path=".${CLI_NAME}/pool";
declare -r __agent_path=".${CLI_NAME}/agent";
declare -r __log_path=".${CLI_NAME}/log";
declare -r __tmp_path=".${CLI_NAME}/tmp";
declare -r __cc_path=".${CLI_NAME}/cc";


################################################################################
# utilities
################################################################################
private::info() { 
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if ! [[ -t 0 ]]; then
        printf "${*:2}\n"
        return 0
    fi

    if [[ ${silent} == false ]]; then
        printf "\033[1;34m${*:2}\033[0m\n";
    fi
}

private::warn() { 
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if ! [[ -t 0 ]]; then
        printf "${*:2}\n"
        return 0
    fi

    if [[ ${silent} == false ]]; then
        printf "\033[1;33m${*:2}\033[0m" 1>&2; 
    fi
}

private::error(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if ! [[ -t 0 ]]; then
        printf "${*:2}\n"
        return 0
    fi

    if [[ ${silent} == false ]]; then
        printf "\033[1;31m${*:2}\033[0m" 1>&2;
    fi
}

private::title(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if ! [[ -t 0 ]]; then
        printf "${*:2}\n"
        return 0
    fi

    if [[ ${silent} == false ]]; then
        printf "\033[1;37m${*:2}\033[0m\n";
    else
        printf "\033[1;37m${*:2}\033[0m\n" >> $__log_path/silent.txt 2>&1
    fi
}

private::print() { 
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "${*:2}\n";
    else
        printf "${*:2}\n" >> $__log_path/silent.txt 2>&1
    fi
}

private::printf(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r silent=${1:-false}

    if [[ ${silent} == false ]]; then
        printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "${*:2}-" "-" | tr ' -' '. ';
    fi
}

private::color(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -r mode=${1}
    if [[ $mode == fg ]]; then
        declare -ir style=38
    elif [[ $mode == bg ]]; then
        declare -ir style=48
    else
        cat /dev/stdin
    fi

    ### save the input
    sponge /tmp/bc.txt

    for args in ${@}; do
        IFS== read match color <<< "$args"
        while read line; do
            if [[ "$line" =~ $match ]]; then
                echo -e "\033[$style;2;$((16#${color:0:2}));$((16#${color:2:2}));$((16#${color:4:2}))m$line\033[m"
            else
                echo "$line"
            fi
        done < /tmp/bc.txt | sponge /tmp/bc.txt
    done

    ### print the result
    cat /tmp/bc.txt
}

function reply_msg(){
    private::debug $LINENO "@: ${@}";

    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    private::debug $LINENO "args[@]: ${args[@]}";
    private::debug $LINENO "!args[@]: ${!args[@]}";

    declare -r newline_flag="${args[newline]:-true}"
    declare -r result="${args[res]:-undefined}"
    declare -ir return=${args[return]:-0}
    declare -r show=${args[show]:-false}

    if [[ ${show} == false ]]; then
        return $EXIT_SUCCESS
    fi

    if [[ $newline_flag == true ]]; then
        declare -r newline=$'\n'
    else
        declare -r newline=""
    fi


    declare -r final_reply_msg_i="${newline}\
res: $result
aid: ${agent_info[id]:-undefined}
pid: ${pool_info[id]:-undefined}
arn: ${agent_info[realname]:-undefined}
usr: ${username:-${user:-undefined}}"

    declare -r final_reply_msg="${newline}\
res: $result
aid: ${agent_info[id]:-undefined}
pid: ${pool_info[id]:-undefined}
arn: ${agent_info[realname]:-undefined}
usr: <code>${username:-${user:-undefined}}</code>"


    if [[ -t 0 ]]; then
        printf "$final_reply_msg_i\n"
    else
        printf "$final_reply_msg\n"
    fi

    if (( $return == $ERR_EXIT_IMD )); then
        exit $ERR_EXIT_IMD
    else
        return ${return:-0}
    fi
}

################################################################################
# jq / yq functions
################################################################################
jq::summary(){
    declare -r server=${1##*/}
    declare -ir count=${2}
    declare -r active=${3:-all}


    if (( $count == 0 )); then
        jq --null-input '{ user: "undefined", byte: "?", sessions: "?", server: "'$server'"}'
    else
        case $active in
            true )
                jq --exit-status '
                    .server_loc as $location |
                    .users[] |
                    select((.downlinkBytes + .downlinkBytes) != 0) |
                {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }' || \
                jq '
                    .server_loc as $location |
                {
                    user: "?",
                    byte: "?",
                    session: "?",
                    active: "?",
                    server: $location
                }' < $api_addr_json_file
            ;;
            false )
                jq '
                    .server_loc as $location |
                    .users[] |
                    select((.downlinkBytes + .downlinkBytes) == 0) | {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }'
            ;;
            all )
                jq '
                    .server_loc as $location |
                    .users[] | {
                    user: .username,
                    byte: (.downlinkBytes + .uplinkBytes), 
                    session: (.tcpSessions + .udpSessions), 
                    active: ((.downlinkBytes + .uplinkBytes) > 0), 
                    server: $location
                }'
            ;;
        esac
    fi
}

jq::table(){
    if [[ $1 == true ]]; then
        jq -sr  '. as $root | $root[0] | to_entries | map(.key) | join(" ") as $H | $H, ($root[] | to_entries | map(.value|tostring) | join(" "))' | \
        column -t
    else
        jq
    fi
}

yq::table(){
    if [[ $1 == true ]]; then
        yq -r '. as $R | ($R[0] | to_entries | map(.key) | join(" ")) as $H | ($H, $R[] | to_entries | map(.value) | join(" "))' | \
        column -t
    else
        yq '.'
    fi
}

jq::user_stat(){
    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r user=${args['user']:-$user}

    jq '.users | map({ user: .username, name: "name", bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
        jq '.[] | select(.user=="'$username'")' | \
        jq -s '
            (map(.bytes)|add) as $bytes |
        {
            user: .[0].user,
            name: $user[0].realname,
            bytes: (map(.bytes)|add),
            sessions: (map(.sessions)|add),
            status: (if ($bytes > 0) then "connected" else "created" end)
        }' --slurpfile user $table_users/${user}.json
}

jq::user_init(){
    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r user=${args[user]:-undefined};

    jq --null-input '
        ($config[0].traffic | tonumber) as $bytes |
        ($config[0].period | tonumber) as $seconds |

    {
        user: $config[0].username,
        name: $config[0].realname,
        sessions: 0,
        ctime: (now|floor),
        atime: 0,
        etime: ((now|floor)+$seconds),
        bytes: {
            base: $bytes,
            used: 0,
            pday: 0,
            limit: false
        },
        seconds: {
            base: $seconds,
            used: 0,
            limit: false
        }
    }' --slurpfile config $table_users/${user}.json
}

jq::user_update(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args=();
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r delink=${args[delink]:-true};
    declare -r user_bytes_file=${table_bytes}/${user}.json

    declare -i last_bytes=$(private::user_bytes user=$user)
    declare -i user_bytes=$(jq '.bytes.used' < $user_bytes_file)
    if (( last_bytes == user_bytes )); then
        echo ignored
        return 0
    fi

    private::user_stat user=$user caller=$fn_name | \
    jq '
        .bytes as $bytes |
        .sessions as $sessions |
        ($data[0]) as $data |
        ((now|floor)-$data.ctime) as $second_used |
        ((((now|floor)-$data.ctime)/(24*60*60))|floor) as $day_used |
        (.bytes / (if ($day_used==0) then 1 else $day_used end)) as $pday |

        $data |

        .sessions = $sessions |
        .atime = (now|floor) |
        .bytes.used = $bytes |
        .bytes.pday = $pday |
        .seconds.used = $second_used

    ' --slurpfile data $user_bytes_file | \
        sponge $user_bytes_file
        echo 'updated'

    ### generate a static page for it
    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$user
    declare -r user_profile_index_html=$user_profile_path/index.html
    declare -r user_fetch_file=$user_profile_path/${user}.json

    # declare -r bytes_used=$(jq '.bytes.used' < $user_bytes_file)
    # declare -r seconds_used=$(jq '.seconds.used' < $user_bytes_file)
    # declare -r sessions=$(jq '.sessions' < $user_bytes_file)

    # ### update user data on index.html
    # perl -i -s -lpe 's/(?<=id="user-bytes">)\d*(?=<\/span>)/$arg/' -- -arg=$bytes_used $user_profile_index_html
    # ### day
    # perl -i -s -lpe 's/(?<=id="user-seconds">)\d*(?=<\/span>)/$arg/' -- -arg=$seconds_used $user_profile_index_html
    # ### sessions
    # perl -i -s -lpe 's/(?<=id="user-sessions">)\d*(?=<\/span>)/$arg/' -- -arg=$sessions $user_profile_index_html

    # if ! [[ -f $user_fetch_file ]]; then
    if jq --exit-status '.bytes.used == 0' < $user_fetch_file > /dev/null 2>&1; then
        if [[ $delink == true ]]; then
            ### remove the link, should we ?
            perl -i -s -lpe 's/(?<=value=").*?(?=")/$arg/' -- -arg="removed-by-admin" $user_profile_index_html
            # perl -i -s -lne '!/$arg/ && print' -- -arg='img src=' $user_profile_index_html
            perl -i -s -lpe 's/(?<=img src=").*?(?=" alt=)//' $user_profile_index_html
            rm -f ${user_profile_path}/!(index.html)
        fi
    fi

    rsync -az $user_bytes_file $user_profile_path/
}

################################################################################
# user command
################################################################################
private::user_create(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r force=${args['force']:-false}
    declare -r renew=${args['renew']:-false}

    declare -r username_random=$(openssl rand -hex 3)
    declare -r profile_random=$(openssl rand -hex 5)

    declare -r username=${args['user']:-${username_random}}
    declare -r ss_username="${agent_prefix}${username}"
    declare -r user_traffic=${args[traffic]:-${pool_info[traffic]}}
    declare -r user_period=${args[period]:-${pool_info[period]}}

    declare -r user_realname=${args['name']:-${args['n']:-}}
    declare -r profile_name=${args['profile']:-${args['p']:-${user_realname:-}}}

    declare -r password=$(openssl rand -base64 16)
    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r user_data_file=${table_users}/${username}.json

    declare old_password=""
    declare old_realname=""
    declare -i period_second=0
    declare -i traffic_bytes=0


    declare -r user_period_unit=${user_period: -1}
    declare -r user_traffic_unit=${user_traffic: -1}

    case $user_period_unit in
        h )
            period_second=$(( ${user_period//[a-z]/} * 60 * 60 ))
        ;;
        m )
            period_second=$(( ${user_period//[a-z]/} * 60 ))
        ;;
        s )
            period_second=${user_period//[a-z]/}
        ;;
        * )
            period_second=$(( ${user_period//[a-z]/} * 24 * 60 * 60 ))
        ;;
    esac
    case $user_traffic_unit in
        m )
            traffic_bytes=$(( ${user_traffic//[a-z]/} * 1024 * 1024 ))
        ;;
        k )
            traffic_bytes=$(( ${user_traffic//[a-z]/} * 1024 ))
        ;;
        b )
            traffic_bytes=${user_traffic//[a-z]/}
        ;;
        * )
            traffic_bytes=$(( ${user_traffic//[a-z]/} * 1024 * 1024 * 1024 ))
        ;;
    esac

    : ${args[stop]:+${args[nothing]:?stop here at $LINENO}}


    ### make sure agent_prefix is not duplicated
    if [[ ${username} =~ ^$agent_prefix ]]; then
        reply_msg res="error, username format is incorrect ${username}" \
            return=$ERR_EXIT_IMD show=true newline=false
    fi

    ### the agent path should be created
    if ! [[ -d $table_users/ ]]; then
        reply_msg res='error, users table not found, run db init first' \
            return=$ERR_EXIT_IMD show=true newline=false
    fi

    if [[ -f $user_data_file ]]; then
        if [[ $renew == false ]]; then
            reply_msg res="error, user=$username already created, renew=true to renew" \
                return=$ERR_EXIT_IMD show=true newline=false
        fi
    else
        if [[ -z $user_realname ]]; then
            reply_msg res='error, name of the new user?, name=NAME' \
                return=$ERR_EXIT_IMD show=true newline=false
        fi
    fi

    ### make sure all servers are up
    private::server_check silent=true $@

    ### generate a static page for the user
    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$username
    declare -r user_profile_index_html=$user_profile_path/index.html
    declare -r agent_index_html=$dash_path/${agent_info[groupname]}.html

    if ! [[ -f $agent_index_html ]]; then
        reply_msg res="error, agent index $agent_index_html not found" \
            return=$ERR_EXPR_FAILED show=true newline=false
    fi

    ### remove old static page
    rm -rf $user_profile_path

    ### make new static page
    mkdir -p $user_profile_path
    rsync -az $agent_index_html $user_profile_index_html

    declare -r user_profile_page=${profile[link]}/${agent_info[groupname]}/$username
    declare -r user_qr_png=${profile_random}.png

    ### iterate over all servers
    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    declare -A server_info=()

    # private::title ${args[silent]:-false} "id location username result"
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

        private::debug $LINENO "nc -tzv ${server_info['api_addr']} ${server_info['api_port']}";

        private::printf ${args[silent]:-false} "create $username"
        # if [[ $(private::server_test) == false ]]; then
        #     private::print ${args[silent]:-false} "failure $ssm_api_addr"

        #     if [[ ${args[force]:-false} == false ]]; then
        #         ### send notification to admins
        #         # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-fetch-failed" | at now +1 minute > /dev/null 2>&1

        #         reply_msg res="error, server=${server_info[location]} is down, force=false"
        #             return=$ERR_EXPR_FAILED show=true newline=${args[silent]:+false}
        #     fi
        # fi

        ### check if used already created or not
        if curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | jq --exit-status '.username=="'$ss_username'"' > /dev/null 2>&1; then
            private::print ${args[silent]:-false} "existed [${server_info[location]}]";
            continue
        fi

        if [[ -f $user_data_file ]]; then
            old_password=$(jq '.uPSK' < $user_data_file)
            curl --silent --request POST --url http://${ssm_api_addr}/server/v1/users --data '{ "username": "'${ss_username}'", "uPSK": '${old_password}' }'
            private::print ${args[silent]:-false} "readded [${server_info[location]}]";
        else
            curl --silent --request POST --url http://${ssm_api_addr}/server/v1/users --data '{ "username": "'${ss_username}'", "uPSK": "'${password}'" }'
            private::print ${args[silent]:-false} "created [${server_info[location]}]";
        fi
    done

    private::debug $LINENO "server_info[@]: ${server_info[@]}";
    private::debug $LINENO "db_info[users]: $table_users";

    ### qr image
    perl -i -s -lpe 's/(?<=img src=").*?(?=" alt=)/$arg/' -- -arg=$user_qr_png $user_profile_index_html
    ### remote link
    # perl -i -s  -lpe 's/(?<=id="user-remote-link">).*?(?=<\/a>)/$arg/' -- -arg="$user_profile_page/profile" $user_profile_index_html
    perl -i -s -lpe 's/(?<=value=").*?(?=")/$arg/' -- -arg="$user_profile_page/$profile_random" $user_profile_index_html

    ### save the new user
    if [[ $renew == false ]]; then
        curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | \
        jq --exit-status '
        {
            username: "'$username'",
            realname: "'$user_realname'",
            ctime: (now|todate),
            period: '$period_second',
            traffic: '$traffic_bytes',
            uPSK: .uPSK,
            page: "'$user_profile_page'/",
            profile: "'$profile_random'"
        }' | sponge $user_data_file
    fi

    ### generate new configs
    private::user_config aid=$agent_id user=$username name=$user_realname method=local show=false force=true "$@"
    private::user_config aid=$agent_id user=$username name=$user_realname method=link show=false "$@"
    private::user_config aid=$agent_id user=$username name=$user_realname method=link type=qr show=false "$@"

    jq::user_init user=$username | \
    jq 'del(.name)' | \
    sponge $user_profile_path/${username}.json

    private::server_fetch silent=true $@

    reply_msg res="page: $user_profile_page/" show=true \
        newline=${args[silent]:+false}
}

private::user_delete(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r ss_username="${agent_prefix}${username}"

    declare -r force=${args['force']:-false}
    declare -r select=${args['select']:-undefined}

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    
    if [[ -z $username ]]; then
        reply_msg res='error, user=USERNAME ?' return=$ERR_EXPR_FAILED show=true newline=false
    fi

    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    declare -A server_info=()

    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

        private::debug $LINENO "nc -tzv ${server_info['api_addr']} ${server_info['api_port']}";

        if [[ $username == all ]] && [[ $force == true ]]; then
            declare all_users=()
            case $select in
                local )
                    ### all local users
                    # mapfile -t all_users < <(ls -1 $table_users | sed 's/.json//g')
                    declare -a all_users=($(echo $table_users/*))
                    all_users=(${all_users[@]%%.json})
                    all_users=(${all_users[@]/*\//$agent_prefix})
                ;;
                remote )
                    ### all remote users
                    mapfile -t all_users < <(
                        curl --silent -X GET --url http://${ssm_api_addr}/server/v1/users | \
                        jq '.users[] |=  select(.username | test("^'${agent_prefix}'"))' |
                        jq -r '.users[].username' | \
                        sort
                    )
                ;;
                * )
                    reply_msg res="error, select=<local|remote> ?" show=true \
                        return $ERR_EXPR_FAILED
                ;;
            esac

            for user in ${all_users[@]}; do
                private::printf ${args[silent]:-false} "delete ${user#$agent_prefix}"
                curl --silent --request DELETE --url http://${ssm_api_addr}/server/v1/users/$user
                private::print ${args[silent]:-false} "deleted [${server_info[location]}]"
            done
        else
            private::printf ${args[silent]:-false} "delete $username"
            ### check if used already created or not
            if curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | jq --exit-status '.username=="'$ss_username'"' > /dev/null 2>&1; then
                curl --silent --request DELETE --url http://${ssm_api_addr}/server/v1/users/$ss_username 
                private::print ${args[silent]:-false} "deleted [${server_info[location]}]"
            else
                private::print ${args[silent]:-false} "noexist [${server_info[location]}]"
            fi
        fi
    done

    private::debug $LINENO "server_info[@]: ${server_info[@]}";
    private::server_fetch silent=true $@

    ## declare -A profile=()
    ## mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    ## for line in "${tmp[@]}"; do
    ##     IFS=\ =\  read key value <<< "$line"
    ##     profile[$key]="$value";
    ## done

    ## declare -r dash_path=${profile[web_root]}
    ## declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$username

    ## ### remove the user profile
    ## rm -fr $user_profile_path

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        reply_msg res="user=$username deleted" show=true \
            newline=${args[silent]:+false} ${@}
    fi
}

private::user_renew(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r user=${args[user]:-}
    declare -r name=${args[name]:-}
    declare -r user_data_file=$table_users/${user}.json

    if [[ -z $user ]]; then
        reply_msg res="error, a user=USERNAME to renew?" show=true \
            return=$ERR_EXIT_IMD newline=false
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error, user=$user info not found" \
            return=$ERR_EXIT_IMD show=true newline=false
    fi

    ### delete the user
    private::user_delete user=$user silent=true

    ### readd the user
    declare -r user_realname=$(jq -r '.realname' < $user_data_file)
    private::user_create user=$user name=$user_realname renew=true
}

private::user_lock(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r username=${args[user]:-}
    declare -r ss_username="${agent_prefix}${username}"
    declare -r name=${args[name]:-}
    declare -r user_data_file=$table_users/${username}.json

    if [[ -z $username ]]; then
        reply_msg res="error, a user=USERNAME to lock?" show=true \
            return=$ERR_EXIT_IMD newline=false
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error, user=$username info not found" \
            return=$ERR_EXIT_IMD show=true newline=false
    fi

    ### iterate over all servers
    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    declare -A server_info=()
    declare -r random_password=$(openssl rand -base64 16)
    declare -r old_password=$(jq -r '.uPSK' < $user_data_file)

    # private::title ${args[silent]:-false} "id location username result"
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

        ### check if used already created or not
        if ! curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | jq --exit-status '.username=="'$ss_username'"' > /dev/null 2>&1; then
            reply_msg res="error, user=$username not found alive" \
                return=$ERR_EXIT_IMD show=true newline=false
        fi

        private::printf ${args[silent]:-false} "lock $username"
        curl --silent --request PUT --url http://${ssm_api_addr}/server/v1/users/$ss_username --data '{ "uPSK": "'${random_password}'" }'
        private::print ${args[silent]:-false} "locked [${server_info[location]}]";
    done

    reply_msg res=success show=true newline=${args[silent]:+false}
}

private::user_unlock(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r username=${args[user]:-}
    declare -r ss_username="${agent_prefix}${username}"
    declare -r name=${args[name]:-}
    declare -r user_data_file=$table_users/${username}.json

    if [[ -z $username ]]; then
        reply_msg res="error, a user=USERNAME to unlock?" show=true \
            return=$ERR_EXIT_IMD newline=false
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error, user=$username info not found" \
            return=$ERR_EXIT_IMD show=true newline=false
    fi

    ### iterate over all servers
    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    declare -A server_info=()
    declare -r old_password=$(jq -r '.uPSK' < $user_data_file)

    # private::title ${args[silent]:-false} "id location username result"
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

        ### check if used already created or not
        if ! curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | jq --exit-status '.username=="'$ss_username'"' > /dev/null 2>&1; then
            reply_msg res="error, user=$username not found alive on $ssm_api_addr" \
                return=$ERR_EXIT_IMD show=true newline=false
        fi

        private::printf ${args[silent]:-false} "unlock $username"
        curl --silent --request PUT --url http://${ssm_api_addr}/server/v1/users/$ss_username --data '{ "uPSK": "'${old_password}'" }'
        private::print ${args[silent]:-false} "unlocked [${server_info[location]}]";
    done

    reply_msg res=success show=true newline=${args[silent]:+false}
}

private::user_config(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done


    declare -r username=${args['user']:-}
    declare -r force=${args['force']:-false}
    declare -r user_realname=${args['name']:-${args['n']:-}}
    declare -r profile_name=${args['profile']:-${args['p']:-${user_realname:-}}}


    declare -r type=${args['type']:-json}
    declare -r method=${args['method']:-${args['met']:-${args['m']:-link}}}

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r table_configs=${db_info[root]}/${agent_info[groupname]}/${db_info[configs]}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    declare -r client_sample_file=$__cc_path/${agent_id}.json
    declare -r user_data_file=${table_users}/${username}.json
    declare -r user_config_file=${table_configs}/${username}.json


    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        if ! jq --exit-status '.users[] | select(.username=="'$username'")' $table_servers/*.json > /dev/null 2>&1; then
            reply_msg res="error, user=$username has been deleted or server out of sync" \
                return=$ERR_EXPR_FAILED show=true newline=false
        fi
    fi

    if [[ -z $username ]]; then
        reply_msg res='error, user=USERNAME ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -d $table_configs/ ]]; then
        reply_msg res='error, configs table not found, run db init first' \
            return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error, user=$username not found" \
            return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $client_sample_file ]]; then
        reply_msg res="error, $client_sample_file not found" \
            return=$ERR_EXPR_FAILED show=true
    fi

    ### direct assignment because of args parser removing '='
    declare -r pass_ss=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass.ss' < $pool_servers_file )
    declare -r pass_tls=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass.tls' < $pool_servers_file )

    declare -r profile_random=$(jq -r '.profile' < $user_data_file)
    declare -r pass_user=$(jq -r '.uPSK' < $user_data_file)
    declare -r pass_user_final="${pass_ss}:${pass_user}"
    private::debug $LINENO "pass_user: $pass_user";
    private::debug $LINENO "pass_user_final: $pass_user_final";

    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r dash_link=${profile[link]}

    declare -r user_profile_page=${dash_link}/${agent_info[groupname]}/$username
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/$username
    declare -r user_profile_index_html=$user_profile_path/index.html
    declare -r user_profile_file=$user_profile_path/$profile_random

    declare -r user_qr_png=${profile_random}.png
    declare -r user_url="${user_profile_page}/$profile_random#${profile_name:-$username}"

    if ! [[ -f $client_sample_file ]]; then
        reply_msg res="error $client_sample_file not found" show=true \
            newline=true return=$ERR_EXPR_FAILED
    fi

    # if [[ -f $user_config_file ]] &&
    #     [[ $force == false ]] &&
    #     [[ $method == local ]]; then
    #     ### remove older generated files
    #     # return 0
    #     reply_msg res="warning, ${username}.json config found, use force=true to update" show=true \
    #         return=$ERR_EXPR_FAILED
    # fi

    if [[ -f $user_config_file ]]; then
        if [[ $force == true ]] && [[ $method == local ]]; then
            mv $user_config_file ${user_config_file}.old || true
        fi
    fi

    if [[ $pass_tls != null ]] && [[ $pass_ss != null ]]; then
        ### create the configuration file
        jq -c '
        (.outbounds[] | select(.type=="shadowsocks") | .password) = "'"$pass_user_final"'" |
        (.outbounds[] | select(.type=="shadowtls") | .password) = "'"${pass_tls}"'"
        ' < $client_sample_file | sponge $user_config_file
    elif [[ $pass_ss != null ]]; then
        jq -c '
        (.outbounds[] | select(.type=="shadowsocks") | .password) = "'"$pass_user_final"'"
        ' < $client_sample_file | sponge $user_config_file
    else
        reply_msg res="error shadowsocks password is not valid" show=true \
            newline=true return=$ERR_EXIT_IMD
    fi

    if [[ $type == json ]]; then
        case $method in
            link )
                rsync -az $user_config_file $user_profile_file

                ### re-add link
                perl -i -s -lpe 's/(?<=value=").*?(?=")/$arg/' -- -arg="$user_profile_page/$profile_random" $user_profile_index_html

                reply_msg res="link: $user_profile_page/$profile_random" \
                    show=true show=true newline=false $@
            ;;

            file )
                # private::telegram_doc user=$username file=$user_config_file
                echo "cd $PWD && ${0} tell doc user=$username aid=$agent_id file=$user_config_file" | at now +1 minute > /dev/null 2>&1

                reply_msg res="file: <code>${username}.json</code> is uploading ..." \
                show=true $@
            ;;

            local )
                reply_msg res="local: $user_config_file" \
                show=true $@
            ;;

            * )
                reply_msg res="unknown method: $method" show=true \
                    return=$ERR_EXPR_FAILED
            ;;
        esac
    fi

    if [[ $type == qr ]]; then
        case $method in
            link )
                rsync -az $user_config_file $user_profile_file
                echo "sing-box://import-remote-profile?url=$user_url" | \
                    qrencode -s 10 -t PNG -o ${user_profile_path}/$user_qr_png

                ### re-add qr image
                perl -i -s -lpe 's/(?<=img src=").*?(?=" alt=)/$arg/' -- -arg=$user_qr_png $user_profile_index_html

                reply_msg res="link: ${user_profile_page}/$user_qr_png" \
                    show=true newline=false $@

            ;;
            file )
                echo "sing-box://import-remote-profile?url=$user_url" | \
                    qrencode -s 10 -t PNG -o ${user_config_file%.json}.png
                
                # private::telegram_doc user=$username file=${table_configs}/${username}.png
                echo "cd $PWD && ${0} tell doc user=$username aid=$agent_id file=${user_config_file%.json}.png" | at now +1 minute > /dev/null 2>&1

                reply_msg res="file: <code>${username}.png</code> is uploading ..." \
                show=true $@
            ;;
            * )
                reply_msg res="unknown method: $method, type: ${type}" show=true \
                    return=$ERR_EXPR_FAILED
            ;;
        esac
    fi

    if [[ -f $user_profile_path/${username}.json ]]; then
        ### set bytes.used to 0 so in next "app run" will be deleted
        yq -i '.bytes.used=0' $user_profile_path/${username}.json
    fi

    # reply_msg res='create new one, rename old one' show=true newline=true ${@}
}

private::user_stat(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r caller=${args['caller']:-undefined}
    declare -r force=${args['force']:-false}

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}

    if [[ -z $username ]]; then
        reply_msg res='error, user=USERNAME ?' return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi
    
    if ! jq --exit-status '.users[] | select(.username=="'$username'")' $table_servers/*.json > /dev/null 2>&1; then
        case $caller in
            user_list )
                jq --null-input '{
                    user: "'$username'",
                    name: $user[0].realname,
                    bytes: "X", 
                    sessions: "X", 
                    status: "deleted"
                 }' --slurpfile user $table_users/${username}.json

            ;;
            * )
                jq --null-input '{
                    user: "'$username'", 
                    name: $user[0].realname,
                    bytes: "?", 
                    sessions: "?", 
                    status: "?"
                }' --slurpfile user $table_users/${username}.json | \
                    jq::table true
            ;;
        esac
        # reply_msg res="error, user=$username not found offline" return=$ERR_EXPR_FAILED show=true
    else
        # jq '.users | map({user: .username, bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
        #     jq '.[] | select(.user=="'$username'")' | \
        #     jq -s '{ user: (if .[0].user == null then "not-found-offline" else .[0].user end), bytes: (map(.bytes)|add), sessions: (map(.sessions)|add) }'

        case $caller in
            user_list | user_update )
                jq::user_stat
            ;;
            * )
                jq::user_stat user=$username | jq::table true
            ;;
        esac
    fi

    reply_msg res=success ${@}
}

private::user_bytes(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-}
    declare -r force=${args['force']:-false}

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    if [[ -z $username ]]; then
        # reply_msg res='error, user=USERNAME ?' return=$ERR_EXPR_FAILED \
        # show=true newline=false
        yq ea '. as $item ireduce ({}; . * $item ) | .users[] | { "user": .username, "bytes": (.downlinkBytes + .uplinkBytes), "sessions": (.tcpSessions + .udpSessions) }' $table_servers/*.json | jq::table true
        exit $EXIT_SUCCESS
    fi

    if ! jq --exit-status '.users[] | select(.username=="'$username'")' $table_servers/*.json > /dev/null 2>&1; then
        echo 0;
        reply_msg res="error, user=$username not found" return=$ERR_EXPR_FAILED show=true
    else
        jq '.users | map({user: .username, bytes: (.downlinkBytes + .uplinkBytes), sessions: (.tcpSessions + .udpSessions)})' $table_servers/*.json | \
            jq '.[] | select(.user=="'$username'")' | \
            jq -rs '(map(.bytes)|add) '
    fi

    reply_msg res=success ${@}
}

private::user_notif(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]} ;

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}
    declare -r notif_msg=${args['notif']:-${args['msg']:-${args['m']:-}}}
    declare -r archive=${args[archive]:-false}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}

if [[ -z $username ]]; then
    echo "[X] error: user=USERNAME ?"
    exit $ERR_EXPR_FAILED
fi

if [[ -z $notif_msg ]]; then
    echo "[X] error: msg=MESSAGE ?"
    exit $ERR_EXPR_FAILED
fi

    private::user_get "$@" | \
    yq '.user=("<code>" + .user + "</code>")' | \
    private::telegram_msg aid=$agent_id

    ### if a user file is a symbolic link, remove it
    if [[ -L ${table_bytes}/${username}.json ]]; then
        rm -f ${table_bytes}/${username}.json
    fi

    reply_msg res=success ${@}
}

private::user_init(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    ### the agent path be created
    if ! [[ -d $table_bytes/ ]]; then
        reply_msg res='error, users table not found, run db init first' return=$ERR_EXPR_FAILED show=true
    fi

    ### find connected users
    # [inefficient]  mapfile -t local_users < <(ls -1 $table_users | sed 's/.json//g')
    ## mapfile -t online_users < <(jq -r '.users[] | .username' $table_servers/*.json | sort | uniq)
    mapfile -t online_users < <(yq -r eval-all '[.users[] | select((.tcpSessions + .tcpSessions) > 0) | .username] | unique | sort | .[]' $table_servers/*.json | sort | uniq)
    for user in ${online_users[@]}; do
        ## declare -i user_bytes=$(private::user_bytes user=$user)
        ## if (( user_bytes == 0 )); then
        ##     continue
        ## else
            if [ -f $table_bytes/${user}.json ]; then
                private::printf ${args[silent]:-false} "user update $user"
                jq::user_update $@
            else
                private::printf ${args[silent]:-false} "user init $user"
                jq::user_init user=$user | \
                sponge $table_bytes/${user}.json
                echo "init-ed"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg=user-init " | at now +1 minute > /dev/null 2>&1
            fi
        ## fi
    done

    reply_msg res=success ${@}
}

private::user_fetch(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r user_bytes_file=$table_bytes/${username}.json

    if [[ -z $username ]]; then
        reply_msg res='error: user=USERNAME ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="warning: user=$username not connected yet" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    yq -p json -o yaml '.' $table_bytes/${username}.json

    reply_msg res=success ${@}
}
private::user_get(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}
    declare -r notif_msg=${args['notif']:-${args['msg']:-${args['m']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r table_archive=${db_info[root]}/${agent_info[groupname]}/${db_info[archive]}
    declare -r user_bytes_file=$table_bytes/${username}.json
    declare -r user_data_file=$table_users/${username}.json
    declare -r server_name=$(hostname)

    if [[ -z $username ]]; then
        reply_msg res='error: user=USERNAME ?' return=$ERR_EXIT_IMD show=true \
            newline=false
    fi

    if ! [[ -f $user_data_file ]]; then
        reply_msg res="error: user=$username not found" return=$ERR_EXIT_IMD \
            show=true newline=false
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="warning: user=$username not connected yet" return=$ERR_EXIT_IMD \
            show=true newline=false
    fi

jq '

(60 * 60 * 24) as $day |
(60 * 60) as $hour |
(60 * 1) as $minute |

(1024 * 1024 * 1024) as $gig |
(1024 * 1024) as $meg |
(1024 * 1) as $kilo |

(if (.seconds.base >= $day) then .seconds.base=((.seconds.base/$day|floor|tostring) + "d") end) |
(if (.seconds.base >= $hour and .seconds.base < $day) then .seconds.base=((.seconds.base/$hour|floor|tostring) + "h") end) |
(if (.seconds.base >= $minute and .seconds.base < $hour) then .seconds.base=((.seconds.base/$minute|floor|tostring) + "m") end) |
(if (.seconds.base < $minute) then .seconds.base=((.seconds.base|tostring) + "s") end) |

(if (.seconds.used >= $day) then .seconds.used=((.seconds.used/$day|floor|tostring) + "d") end) |
(if (.seconds.used >= $hour and .seconds.used < $day) then .seconds.used=((.seconds.used/$hour|floor|tostring) + "h") end) |
(if (.seconds.used >= $minute and .seconds.used < $hour) then .seconds.used=((.seconds.used/$minute|floor|tostring) + "m") end) |
(if (.seconds.used < $minute) then .seconds.used=((.seconds.used|tostring) + "s") end) |

(if (.bytes.base >= $gig) then .bytes.base=((.bytes.base/$gig|floor|tostring) + "g") end) |
(if (.bytes.base >= $meg and .bytes.base < $gig) then .bytes.base=((.bytes.base/$meg|floor|tostring) + "m") end) |
(if (.bytes.base >= $kilo and .bytes.base < $meg) then .bytes.base=((.bytes.base/$kilo|floor|tostring) + "k") end) |
(if (.bytes.base < $kilo) then .bytes.base=((.bytes.base|tostring) + "b") end) |

(if (.bytes.used >= $gig) then .bytes.used=((.bytes.used/$gig|floor|tostring) + "g") end) |
(if (.bytes.used >= $meg and .bytes.used < $gig) then .bytes.used=((.bytes.used/$meg|floor|tostring) + "m") end) |
(if (.bytes.used >= $kilo and .bytes.used < $meg) then .bytes.used=((.bytes.used/$kilo|floor|tostring) + "k") end) |
(if (.bytes.used < $kilo) then .bytes.used=((.bytes.used|tostring) + "b") end) |

(if (.bytes.pday >= $gig) then .bytes.pday=((.bytes.pday/$gig|floor|tostring) + "g") end) |
(if (.bytes.pday >= $meg and .bytes.pday < $gig) then .bytes.pday=((.bytes.pday/$meg|floor|tostring) + "m") end) |
(if (.bytes.pday >= $kilo and .bytes.pday < $meg) then .bytes.pday=((.bytes.pday/$kilo|floor|tostring) + "k") end) |
(if (.bytes.pday < $kilo) then .bytes.pday=((.bytes.pday|tostring) + "b") end) |


{
  user: .user,
  name: .name,
  sessions: .sessions,
  ctime: (.ctime|todate),
  atime: (.atime|todate),
  etime: (.etime|todate),
  traffic: {
    base: .bytes.base,
    used: .bytes.used,
    pday: .bytes.pday,
    limit: false
  },
  period: {
    base: .seconds.base,
    used: .seconds.used,
    limit: false
  },
  server: {
    app: "sing-box",
    msg: "'"${notif_msg}"'",
    host: "'$server_name'"
  }
}' < $user_bytes_file | \
yq -p json -o yaml

    reply_msg res=success ${@}
}

private::user_list(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare select_status=${args[status]:-}

    declare -r data_int=$(private::data_int bool)
    if [[ $data_int == false ]]; then
        reply_msg res='error, data integrity failure' \
            show=true newline=false return=$ERR_EXIT_IMD
    fi

    if [[ $data_int == empty ]]; then
        reply_msg res='warning, server data not found to test, run server fetch' \
            show=true newline=false return=$ERR_EXIT_IMD
    fi

    # mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    # declare -r random_serve_id=$((RANDOM % ${#server_ids[@]}))

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    mapfile -t users < <(ls -1 $table_users | sed 's/.json//g')

    if [[ ${#users[@]} == 0 ]]; then
        reply_msg res="no user found to list" show=true newline=false \
            return=$ERR_EXIT_IMD
    fi

    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    declare -r random_serve_id=$((RANDOM % ${#server_ids[@]}))

    for sid in "${server_ids[$random_serve_id]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        declare -A server_info=()
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done

        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
        # mapfile -t users < <(curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | jq -r '.users[] | .username')
        for user in ${users[@]}; do
            private::user_stat user=$user caller=$fn_name | \
            # curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$user | jq 'del(.uPSK)'
            # jq 'del(.uPSK,.page,.profile)' < $table_users/${user}.json
            jq 'select(.status | test("'$select_status'"))'
        done | jq::table true
    done

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        reply_msg res="api_addr: $ssm_api_addr, sid: ${random_serve_id}" \
            show=true newline=true $@
    fi
}

private::user_archive(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_archive=${db_info[root]}/${agent_info[groupname]}/${db_info[archive]}
    declare -r user_bytes_file=$table_bytes/${username}.json

    if [[ -z $username ]]; then
        reply_msg res='error: user=USERNAME ?' return=$ERR_EXPR_FAILED show=true
    fi

    if ! [[ -f $user_bytes_file ]]; then
        reply_msg res="bytes for user=$username not found" \
            return=$ERR_FILE_NOT_FOUND show=true newline=false
    fi

    declare -ir time_in_sec=$(date +%s)
    declare -r archive_path=$(date +%Y/%m/%d)

    mkdir -p $table_archive/$archive_path
    declare -r old_user_bytes_file=$table_archive/$archive_path/${username}.json
    declare -r archive_relative_path=../${db_info[archive]}/$archive_path/${username}.json

    if [[ -f $old_user_bytes_file ]]; then
        mv $old_user_bytes_file ${old_user_bytes_file}.${time_in_sec}
    fi

    mv -f $table_bytes/${username}.json $old_user_bytes_file
    ln -fs  $archive_relative_path -t $table_bytes/

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        reply_msg res="user=$username archived" show=true newline=false $@
    fi
}

private::user_limit(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    # declare -r username=${args['user']:-${args['usr']:-${args['u']:-}}}

    declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    # declare -r user_bytes_file=$table_bytes/${username}.json

    # if [[ -z $username ]]; then
    #     reply_msg res='error: user=USERNAME ?' return=$ERR_EXPR_FAILED show=true
    # fi

    # if ! [[ -f $user_bytes_file ]]; then
    #     reply_msg res="error: user=$username not found" return=$ERR_FILE_NOT_FOUND show=true
    # fi

    
    ## mapfile -t online_users < <(jq -r '.users[] | .username' $table_servers/*.json | sort | uniq)
    mapfile -t online_users < <(yq -r eval-all '[.users[] | select((.tcpSessions + .tcpSessions) > 0) | .username] | unique | sort | .[]' $table_servers/*.json)
    declare msg=""
    for user in ${online_users[@]}; do
        ## declare -i user_bytes=$(private::user_bytes user=$user)
        ## if (( user_bytes == 0 )); then
        ##     continue
        ## else
            msg=""
            private::printf ${args[silent]:-false} "${fn_name/_/ } $user"
            
            ### traffic check
            bytes_used=$(jq '.bytes.used >= .bytes.base' < $table_bytes/${user}.json)
            if [[ $bytes_used == true ]]; then
                msg="traffic-finished, deleting user"
                private::warn ${args[silent]:-false} "$msg ... "

                private::user_delete  user=$user silent=true
                private::user_archive user=$user silent=true
                private::server_fetch silent=true

                private::warn ${args[silent]:-false} "done\n"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1

                continue
            fi

            ### expiration check
            seconds_used=$(jq '((now|floor) - .ctime) >= .seconds.base' < $table_bytes/${user}.json)
            if [[ $seconds_used == true ]]; then
                msg="date-expired, deleting user"
                private::warn ${args[silent]:-false} "$msg ... "

                private::user_delete  user=$user silent=true
                private::user_archive user=$user silent=true
                private::server_fetch silent=true

                private::warn ${args[silent]:-false} "done\n"

                ### notify
                echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1

                continue
            fi

            bytes_in24=$(jq '.bytes.used >= (.bytes.base - 1e9)' < $table_bytes/${user}.json)
            if [[ $bytes_in24 == true ]]; then
                msg="traffic-limiting in 24h"
                bytes_limit=$(jq '.bytes.limit' < $table_bytes/${user}.json)
                if [[ $bytes_limit == false ]]; then
                    private::warn ${args[silent]:-false} "$msg\n"
                    jq '.bytes.limit=true' < $table_bytes/${user}.json | \
                    sponge $table_bytes/${user}.json

                    ### notify
                    echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1
                else
                    private::warn ${args[silent]:-false} "has been notifid, $msg\n"
                fi
                continue
            fi

            seconds_in24=$(jq '((now|floor) - .ctime) >= (.seconds.base - (24 * 60 * 60))' < $table_bytes/${user}.json)
            if [[ $seconds_in24 == true ]]; then
                msg='date-expiring in 24h'
                seconds_limit=$(jq '.seconds.limit' < $table_bytes/${user}.json)
                if [[ $seconds_limit == false ]]; then
                    private::warn ${args[silent]:-false} "$msg\n"
                    jq '.seconds.limit=true' < $table_bytes/${user}.json | \
                    sponge $table_bytes/${user}.json

                    ### notify
                    echo "cd $PWD && ${0} user notif user=$user aid=$agent_id msg='$msg'" | at now +1 minute > /dev/null 2>&1
                else
                    private::warn ${args[silent]:-false} "has been notifid, $msg\n"
                fi
                continue
            fi

            private::print ${args[silent]:-false} "ignored"
        ## fi

    done

    reply_msg res=success $@
}

private::user_page(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r user=${args[user]:-}
    declare -r name=${args[name]:-}
    declare -r user_data_file=$table_users/${user}.json

    if [[ -z $user ]] && [[ -z $name ]]; then
        jq 'del(.uPSK,.profile)' $table_users/*.json | \
        jq -s '. | to_entries | .[] |

            (60 * 60 * 24) as $day |
            (60 * 60) as $hour |
            (60 * 1) as $minute |
            (if (.value.period >= $day) then .value.period=((.value.period/$day|floor|tostring) + "d") end) |
            (if (.value.period >= $hour and .value.period < $day) then .value.period=((.value.period/$hour|floor|tostring) + "h") end) |
            (if (.value.period >= $minute and .value.period < $hour) then .value.period=((.value.period/$minute|floor|tostring) + "m") end) |
            (if (.value.period < $minute) then .value.period=((.value.period|tostring) + "s") end) |

            (1024 * 1024 * 1024) as $gig |
            (1024 * 1024) as $meg |
            (1024 * 1) as $kilo |
            (if (.value.traffic >= $gig) then .value.traffic=((.value.traffic/$gig|floor|tostring) + "g") end) |
            (if (.value.traffic >= $meg and .value.traffic < $gig) then .value.traffic=((.value.traffic/$meg|floor|tostring) + "m") end) |
            (if (.value.traffic >= $kilo and .value.traffic < $meg) then .value.traffic=((.value.traffic/$kilo|floor|tostring) + "k") end) |
            (if (.value.traffic < $kilo) then .value.traffic=((.value.traffic|tostring) + "b") end) |

            {
                index: (.key+1),
                user: .value.username,
                name: .value.realname,
                ctime: .value.ctime,
                period:  .value.period,
                traffic: .value.traffic,
                page: .value.page
            }' | jq::table true
    else
        if [[ -f $user_data_file ]]; then
            jq 'del(.uPSK,.profile) |

                (60 * 60 * 24) as $day |
                (60 * 60) as $hour |
                (60 * 1) as $minute |
                (if (.period >= $day) then .period=((.period/$day|floor|tostring) + "d") end) |
                (if (.period >= $hour and .period < $day) then .period=((.period/$hour|floor|tostring) + "h") end) |
                (if (.period >= $minute and .period < $hour) then .period=((.period/$minute|floor|tostring) + "m") end) |
                (if (.period < $minute) then .period=((.period|tostring) + "s") end) |

                (1024 * 1024 * 1024) as $gig |
                (1024 * 1024) as $meg |
                (1024 * 1) as $kilo |
                (if (.traffic >= $gig) then .traffic=((.traffic/$gig|floor|tostring) + "g") end) |
                (if (.traffic >= $meg and .traffic < $gig) then .traffic=((.traffic/$meg|floor|tostring) + "m") end) |
                (if (.traffic >= $kilo and .traffic < $meg) then .traffic=((.traffic/$kilo|floor|tostring) + "k") end) |
                (if (.traffic < $kilo) then .traffic=((.traffic|tostring) + "b") end)

            ' $user_data_file | jq::table true
        else
            if [[ -z $name ]]; then
                reply_msg res="error, user=$user not found" show=true return=$ERR_FILE_NOT_FOUND
            else
                if jq --exit-status 'del(.uPSK,.profile) | select(.realname=="'$name'")' $table_users/*.json > /dev/null 2>&1; then
                    jq 'del(.uPSK,.profile) | select(.realname=="'$name'")' $table_users/*.json | \
                    jq -s '. | to_entries | .[] |

                        (60 * 60 * 24) as $day |
                        (60 * 60) as $hour |
                        (60 * 1) as $minute |
                        (if (.value.period >= $day) then .value.period=((.value.period/$day|floor|tostring) + "d") end) |
                        (if (.value.period >= $hour and .value.period < $day) then .value.period=((.value.period/$hour|floor|tostring) + "h") end) |
                        (if (.value.period >= $minute and .value.period < $hour) then .value.period=((.value.period/$minute|floor|tostring) + "m") end) |
                        (if (.value.period < $minute) then .value.period=((.value.period|tostring) + "s") end) |

                        (1024 * 1024 * 1024) as $gig |
                        (1024 * 1024) as $meg |
                        (1024 * 1) as $kilo |
                        (if (.value.traffic >= $gig) then .value.traffic=((.value.traffic/$gig|floor|tostring) + "g") end) |
                        (if (.value.traffic >= $meg and .value.traffic < $gig) then .value.traffic=((.value.traffic/$meg|floor|tostring) + "m") end) |
                        (if (.value.traffic >= $kilo and .value.traffic < $meg) then .value.traffic=((.value.traffic/$kilo|floor|tostring) + "k") end) |
                        (if (.value.traffic < $kilo) then .value.traffic=((.value.traffic|tostring) + "b") end) |

                        {
                            index: (.key+1),
                            user: .value.username,
                            name: .value.realname,
                            ctime: .value.ctime,
                            period: .value.period,
                            traffic: .value.traffic,
                            page: .value.page
                        }' | jq::table true
                    else
                        reply_msg res="error, user with name=$name not found" show=true return=$ERR_FILE_NOT_FOUND
                    fi
            fi
        fi
   fi
}

private::user_remove(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    declare -r user=${args[user]:-}
    declare -r name=${args[name]:-}
    declare -r user_data_file=$table_users/${user}.json
    declare -r user_data_file_hidden=$table_users/.${user}.json

    if [[ -z $user ]]; then
        reply_msg res="error, a user=USERNAME to remove?" show=true \
            return=$ERR_FILE_NOT_FOUND newline=false
    fi

    if [[ -f $user_data_file ]]; then
        private::user_delete user=$user silent=true
        mv $user_data_file $user_data_file_hidden
        reply_msg res="user=$user removed" show=true
    else
        reply_msg res="warning, a user=$user not found" show=true newline=false \
            return=$ERR_FILE_NOT_FOUND
    fi
}

public::user(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(create delete renew lock unlock config stat bytes init fetch get list page notif archive limit remove print);

    __action_list[create]='create a new user'
    __action_list[delete]='delete a user (server)'
    __action_list[renew]='renew a user';
    __action_list[lock]='lock a user';
    __action_list[unlock]='unlock a user';
    __action_list[config]='get an app configuration';
    __action_list[stat]='stat of a user';
    __action_list[bytes]='sum of bytes of a user';
    __action_list[init]='initialize a user';
    __action_list[fetch]='fetch a user data';
    __action_list[get]='get a user data';
    __action_list[list]='list all users with total bytes';
    __action_list[page]='list user pages';
    __action_list[notif]='notify a user';
    __action_list[archive]='archive a user';
    __action_list[limit]='limit a user';
    __action_list[remove]='remove a user (disk+server)';

    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${server_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value
    # declare -A db_info=()
    # mapfile -t tmp < <(yq ".db" $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"


    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        create | delete | renew | lock | unlock | config | stat | bytes | init | fetch | get | list | page | notif | archive | limit | remove  )
            # private::${__fn_name}_${__action} "$@";
            declare pfn=${__fn_name}_${__action}
            declare -r fn_call_result=$__log_path/$agent_id/${pfn}.txt
            ### interactive shell
            if [[ ${args[bot]:-false} == false ]]; then
                case $pfn in
                    user_list )
                        { private::${pfn} "$@"; } |& tee -a $fn_call_result | private::color ${color:-false} ${match:-deleted}=454545
                    ;;
                    * )
                        { private::${pfn} "$@"; } |& tee -a $fn_call_result
                    ;;
                esac
            else
                declare -r fifo=${db_info[root]}/${agent_id}

                { private::${pfn} "$@" || true; } > $fifo 2>&1 &
                declare -ir pfn_job_pid=$!
                declare -r pfn_job_msg="new job for ${pfn/_/ } queued: <code>$pfn_job_pid</code>"
                echo -e "$pfn_job_msg" > $fifo 2>&1 &
                echo -e "$pfn_job_msg"

                declare -r doc_file=${fn_call_result%.txt}_${pfn_job_pid}.txt
                cat < $fifo > $doc_file

                declare -ir file_size=$(stat -c %s $doc_file)
                if (( file_size < 4096 )); then
                    case $pfn in
                        user_create | user_page | user_renew )
                        cat $doc_file | tee -a $fn_call_result | private::telegram_msg aid=$agent_id silent=true > /dev/null 2>&1
                        ;;
                        * )
                        cat $doc_file | tee -a $fn_call_result | private::telegram_msg aid=$agent_id silent=true code=true > /dev/null 2>&1
                        ;;
                    esac
                else
                    private::telegram_doc aid=$agent_id silent=true file=$doc_file
                fi
            fi
        ;;
        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}


################################################################################
# server command
################################################################################
private::server_check(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -a server_ids=() \
               checked=""

    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    {
        # private::title ${args[silent]:-false} "id location address status"
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done
            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            
            private::printf ${args[silent]:-false} "${fn_name/_/ } ${server_info[location]}"

            checked=$(private::server_test)
            if [[ $checked == true ]]; then
                private::print ${args[silent]:-false} "checked"
            fi

            if [[ $checked == false ]]; then
                private::print ${args[silent]:-false} "failure $ssm_api_addr"

                if [[ ${args[force]:-false} == false ]]; then
                    ### send notification to admins
                    echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg='server=${server_info[location]}, fn=$fn_name, status=failed'" | at now +1 minute > /dev/null 2>&1

                    reply_msg res="error, server=${server_info[location]} is down, force=false" \
                        return=$ERR_EXPR_FAILED show=true newline=true
                fi
            fi



            # # private::print ${args[silent]:-false} "${server_info[id]} ${server_info[location]} ${server_info[api_addr]} "
            # if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
            #     curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
            #     private::print ${args[silent]:-false} "checked"
            # else
            #     private::print ${args[silent]:-false} "failure: ${ssm_api_addr}, admin be will notified ..."


            #     if [[ ${args[force]:-false} == false ]]; then
            #         ### send notification to admins
            #         # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-is-down" | at now +1 minute > /dev/null 2>&1

            #         reply_msg res="error, server=${server_info[location]} is down, force=false" return=$ERR_EXPR_FAILED show=true
            #     fi
            # fi
        done
    } # | column -t

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        # reply_msg res="all servers are up" show=${args[silent]:+true} \
        reply_msg res="all servers are up" show=true \
            newline=${args[silent]:+false} $@
    fi
}

private::server_list(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### jq solution
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    declare active_servers_name=$(yq eval-all -r '[.server_loc] | join(", ")' $table_servers/*.json 2> /dev/null)

    ### jq solution
    # jq  '{ id: .server_id, location: .server_loc, ssm_api: .ssm_api, users: (.users | length) }' $table_servers/*.json | \
    # jq::table true

    ### bash solution
    # mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    # {
    #     private::title ${args[silent]:-false} "id location address port"
    #     for sid in "${server_ids[@]}"; do
    #         mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
    #         declare -A server_info=()
    #         for line in "${props[@]}"; do
    #             IFS=\ =\  read key value <<< "$line"
    #             server_info[$key]="$value";
    #         done

    #         echo ${server_info[id]} ${server_info[location]} ${server_info[api_addr]} ${server_info[api_port]}
    #     done
    # } | column -t

    ### yq solution
    yq ".servers" $pool_servers_file | yq::table true

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        reply_msg res="active servers: ${active_servers_name:-none}" show=true \
            newline=${args[silent]:+false} "$@"
    fi
}

private::server_fetch(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    ### check servers are up/down
    ### can cause some bugs, find a better solution
    ### probably a single server_check function to check every server well called
    # private::server_check silent=true force=${args[force]:-false}

    declare -a server_ids=() \
               fetched=""

    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    {
        # private::title ${args[silent]:-false} "id location address result"
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            api_addr_json_file=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}/${server_info[api_addr]}.json

            private::printf ${args[silent]:-false} "${fn_name/_/ } ${server_info[location]}"

            fetched=$(private::server_test)
            if [[ $fetched == true ]]; then
                curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | \
                    jq '.server_id = '$sid' | .ssm_api = "'$ssm_api_addr'" | .server_loc = "'${server_info[location]}'"' | \
                    jq '.users[] |=  select(.username | test("^'${agent_prefix}'")) | .users[].username |= sub("'${agent_prefix}'"; "") | (.users[].agent_id |= '$agent_id')' |
                    sponge $api_addr_json_file 2>&1
                private::print ${args[silent]:-false} "fetched"
            fi

            if [[ $fetched == false ]]; then
                private::print ${args[silent]:-false} "failure $ssm_api_addr"

                if [[ ${args[force]:-false} == false ]]; then
                    ### send notification to admins
                    echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg='server=${server_info[location]}, fn=$fn_name, status=failed'" | at now +1 minute > /dev/null 2>&1

                    reply_msg res="error, server=${server_info[location]} is down, force=false" \
                        return=$ERR_EXPR_FAILED show=true newline=${args[silent]:+false}
                fi
            fi
        done
    } # |  column -t

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        reply_msg res="all servers fetched" show=true \
            newline=${args[silent]:+false} $@
    fi
}

private::server_stat(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r query=${args['query']:-offline}
    declare -r table=${args['table']:-true}

    declare -i server_id=${args['sid']:--1}
    declare -a server_ids=()

    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)

    if (( $server_id != -1 )); then
        server_ids=($server_id)
        # declare -r yq_server_id=$((server_id - 1))

        ### NOTE
        ### yq can match negative index for an array, e.g. -1 matches last index
        if ! yq --exit-status ".servers[$(($server_id-1))].id" $pool_servers_file > /dev/null 2>&1; then
            reply_msg res="error server-id $server_id not found" show=true \
            return=$ERR_EXPR_FAILED
        fi
    fi

    declare -i count=0
    if [[ $query == offline ]]; then
        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            api_addr_json_file=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}/${server_info[api_addr]}.json

            if ! [[ -f $api_addr_json_file ]]; then
                reply_msg res="error, data for ${server_info[api_addr]} not found" \
                    return=$ERR_FILE_NOT_FOUND show=true
            fi

            count=$(jq '.users | length' < $api_addr_json_file)
            private::title ${args[silent]:-false} "location=${server_info[location]}, users=$count, query=offline"

            if (( count == 0 )); then
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            else
                jq < $api_addr_json_file | \
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            fi

            if [[ $sid != ${server_ids[${#server_ids[@]}-1]} ]]; then
                echo
            fi
        done
    elif [[ $query == online ]]; then
        ### all server should be up
        private::server_check silent=true

        for sid in "${server_ids[@]}"; do
            mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
            declare -A server_info=()
            for line in "${props[@]}"; do
                IFS=\ =\  read key value <<< "$line"
                server_info[$key]="$value";
            done

            ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
            api_addr_json_file=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}/${server_info[api_addr]}.json

            count=$(
                curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | \
                jq '.users[] |=  select(.username | test("^'${agent_prefix}'"))' | \
                jq '.users | length'
            )
            private::title ${args[silent]:-false} "location=${server_info[location]}, users=$count, query=online"

            if (( count == 0 )); then
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            else
                curl --silent --request GET --url http://${ssm_api_addr}/server/v1/stats | \
                jq '.users[] |=  select(.username | test("^'${agent_prefix}'")) | .users[].username |= sub("'${agent_prefix}'"; "")' | \
                jq '.server_id = '$sid' | .ssm_api = "'$ssm_api_addr'" | .server_loc = "'${server_info[location]}'"' | \
                jq::summary ${server_info[api_addr]} $count ${args[active]:-all} | \
                jq::table $table
            fi

            if [[ $sid != ${server_ids[${#server_ids[@]}-1]} ]]; then
                echo
            fi
        done
    fi

    # declare -r fn_call_result=$__log_path/$agent_id/$fn_name.txt
    # cat $fn_call_result
    # if [[ -s $fn_call_result ]]; then
    #     # private::cat show=${args[silent]:+}
    #     cat $fn_call_result
    # else
    #     echo "file $fn_call_result not found or is empty"
    #     exit $ERR_FILE_NOT_FOUND
    # fi
    # reply_msg res=success ${@}

    if [[ ${#FUNCNAME[@]} == 4 ]]; then
        # reply_msg res="all servers are up" show=${args[silent]:+true} \
        reply_msg res="stat of ${#server_ids[@]} servers" show=true \
            newline=${args[silent]:+false} $@
    fi
}

private::server_test(){
    if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
        curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
        printf "true\n";
    else
        printf "false\n";

        ### send notification to admins
        # echo "cd $PWD && ${0} telegram msg user=${agent_info[groupname]} aid=$agent_id msg=server=${server_info[location]}-is-down" | at now +1 minute > /dev/null 2>&1
    fi
}

public::server(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(check list fetch stat print);

    __action_list[check]='check if servers are up/down'
    __action_list[list]='list of servers'
    __action_list[fetch]='fetch servers data'
    __action_list[stat]='stat servers data'
    __action_list[print]='print info'

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi

    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done


    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${server_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value
    # declare -A db_info=()
    # mapfile -t tmp < <(yq ".db" $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"

    
    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;

        check | list | fetch | stat )
            declare pfn=${__fn_name}_${__action}
            declare -r fn_call_result=$__log_path/$agent_id/${pfn}.txt
            ### interactive shell
            if [[ ${args[bot]:-false} == false ]]; then
                { private::${pfn} "$@"; } |& tee -a $fn_call_result
            else
                declare -r fifo=${db_info[root]}/${agent_id}

                { private::${pfn} "$@" || true; } > $fifo 2>&1 &
                declare -ir pfn_job_pid=$!
                declare -r pfn_job_msg="new job for ${pfn/_/ } queued: <code>$pfn_job_pid</code>"
                echo -e "$pfn_job_msg" > $fifo 2>&1 &
                echo -e "$pfn_job_msg"

                declare -r doc_file=${fn_call_result%.txt}_${pfn_job_pid}.txt
                cat < $fifo > $doc_file

                declare -ir file_size=$(stat -c %s $doc_file)
                if (( file_size < 4096 )); then
                    cat $doc_file | tee -a $fn_call_result | private::telegram_msg aid=$agent_id silent=true code=true > /dev/null 2>&1
                else
                    private::telegram_doc aid=$agent_id silent=true file=$doc_file
                fi
            fi
        ;;

        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}

################################################################################
# agent command
################################################################################
private::agent_init(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r admin_samples=(
        $__pool_path/sample.11.yaml
        $__pool_path/sample.21.yaml
        $__cc_path/sample.2.json
        $__cc_path/sample.1.json
        $__agent_path/sample.2.yaml
        $__agent_path/sample.1.yaml
    )

    for src in "${admin_samples[@]}"; do
        dst=${src/sample./}
        private::printf ${args[silent]:-false} "init $dst"
        if ! [[ -f $dst ]]; then
            cat $src > $dst
            private::print ${args[silent]:-false} "created"
        else
            private::print ${args[silent]:-false} "existed"
        fi
    done

    reply_msg res="agents were initialized" show=true \
        newline=${args[silent]:+false} $@
}

private::agent_pool(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r new_pool_id=${args['pid']:-}
    declare -r active_pool_id=${new_pool_id:-${agent_info[pool_id]}}

    ### update the file
    if [[ $active_pool_id == ${agent_info[pool_id]} ]]; then
        ${args[silent]:-false} || yq --exit-status ".pools" $agent_config_file | yq::table true

        reply_msg res="current pool-id: ${active_pool_id}" show=true \
            newline=${args[silent]:+false} $@
        exit $EXIT_SUCCESS
    fi

    if [[ -n $new_pool_id ]]; then
        private::debug $LINENO new_pool_id: $new_pool_id
        private::debug $LINENO agent_config_file: $agent_config_file

        ### check for access
        if ! yq --exit-status ".pools[] | select(.id==$new_pool_id)" $agent_config_file > /dev/null 2>&1; then
            reply_msg res="error, pool-id: ${new_pool_id} not found" show=true return=$ERR_EXPR_FAILED $@
        fi

        ### update the file
        yq --exit-status -i '.agent.pool_id='${new_pool_id}'' $agent_config_file

        ${args[silent]:-false} || \
        yq --exit-status -o json  ".pools[] | select(.id==${active_pool_id})" \
            $agent_config_file | jq::table true
    fi

    reply_msg res="set new pool-id: ${active_pool_id}" show=true \
        newline=${args[silent]:+false} $@
}

private::agent_server(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};
    
    declare -r new_pool_id=${args['pid']:-}
    declare -r active_pool_id=${new_pool_id:-${agent_info[pool_id]}}

    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml
    private::debug $LINENO pool_servers_file: $pool_servers_file

    ### update the file
    if [[ $active_pool_id == ${agent_info[pool_id]} ]]; then
        if ! [[ -f $pool_servers_file ]]; then
            reply_msg res="error pool-id file ${agent_pool_id}.yaml not found" show=true return=$ERR_EXPR_FAILED
        fi

        yq --exit-status '.servers' $pool_servers_file | \
            yq::table true
            # yq -r  '. as $R | ($R[0] | to_entries | map(.key) | join(" ")) as $H | ($H, $R[] | to_entries | map(.value) | join(" "))'

        # reply_msg res=success show=true newline=true $@
    else
        reply_msg res="current pool-id is NOT: ${active_pool_id}" show=true
        exit $EXIT_SUCCESS
    fi
}


public::agent(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(init pool server print);

    __action_list[init]='initialize agents'
    __action_list[pool]='list of pools or select a pool'
    __action_list[server]='list of servers'
    __action_list[print]='print info'

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    if [[ $agent_id == 0 ]]; then
        private::agent_init
        exit 0
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    # yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    # ### map key and value for pool_info
    # mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     pool_info[$key]="$value";
    # done
    # private::debug $LINENO "pool_info: ${pool_info[@]}";
    # private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # ### map key and value for db_info
    # declare -A db_info=()
    # db_info[name]=${agent_info[groupname]}
    # db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    # mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    # for line in "${tmp[@]}"; do
    #     IFS=\ =\  read key value <<< "$line"
    #     db_info[$key]="$value";
    # done
    # private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        pool | server )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}


################################################################################
# db
################################################################################
private::data_init(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### table initialization
    mapfile -t table_list < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables[]' $pool_servers_file)
    for table in ${table_list[@]}; do
        new_path=${db_info[root]}/${agent_info[groupname]}/$table

        # private::printf ${args[silent]:-false]} create: ${db_info[root]}/${agent_info[groupname]}/$table
        private::printf ${args[silent]:-false} "init $new_path"
        mkdir -p $new_path
        private::print ${args[silent]:-false} "created"
    done

    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r agent_index_html=$dash_path/${agent_info[groupname]}.html
    declare -r sample_html=${dash_path}/${profile[sample]}

    if ! [[ -f $agent_index_html ]]; then
        private::printf ${args[silent]:-false} "init $agent_index_html"
        rsync -az $sample_html $agent_index_html
        private::print ${args[silent]:-false} "created"
    fi

    # declare -r table_configs=${db_info[root]}/${agent_info[groupname]}/${db_info[configs]}
    # declare -r client_sample_file=$__cc_path/${agent_id}.json

    ### readable name to random names
    private::printf ${args[silent]:-false} "init ${db_info[root]}/${agent_info[realname]}"
    rm -f ${db_info[root]}/${agent_info[realname]}
    ln -sf ${agent_info[groupname]} ${db_info[root]}/${agent_info[realname]}
    private::print ${args[silent]:-false} "created"

    ### mkfifo with each
    private::printf ${args[silent]:-false} "init ${db_info[root]}/${agent_id}"
    mkfifo ${db_info[root]}/${agent_id} > /dev/null 2>&1 || true
    private::print ${args[silent]:-false} "created"

    ### log dir per agent
    private::printf ${args[silent]:-false} "init log/$agent_id"
    mkdir -p $__log_path/${agent_id}
    private::print ${args[silent]:-false} "created"

    reply_msg res=success ${@}
}

private::data_info(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    ### table initialization
    yq '.db.info[] | select(.name=="'${agent_info[groupname]}'")' $pool_servers_file

    reply_msg res=success ${@}
}

private::data_test(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r query=${args[query]:-offline}

    echo "#### $(date '+%F-%A-%T') ####"

    if [[ $query == online ]]; then
        ### fetch data from servers
        private::server_fetch aid=$agent_id
    fi

    private::title false "\ndata tests"
    private::printf false "user integrity"
    declare -r test=$(private::data_int bool)
    private::data_int string
    if [[ $test == false ]]; then
        private::data_int table
    fi


    reply_msg res=success ${@}
}

private::data_int(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -r type=${1:-string}
    declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}

    mapfile -t server_files < <(find $table_servers -name \*.json)
    if [[ ${#server_files[@]} == 0 ]]; then
        echo empty
        exit $EXIT_SUCCESS
    fi

    case $type in
        boolean | bool | b )
            jq '.users | length' ${table_servers}/*.json | jq -rs '(max == min)'
        ;;
        string | str | s )
            jq '.users | length' ${table_servers}/*.json | jq -rs 'if (max == min) then "passed" else "failure" + " min:" + (min|tostring) + " max:" + (max|tostring) end'
        ;;
        table )
            jq '{ location: .server_loc, users: (.users | length)}' ${table_servers}/*.json  | \
                jq -rs '.[].min=(map(.users)|min) | .[].max=(map(.users)|max) | map({source: .location, users: .users, failure: (.users!=.max)}) | .[]' | \
                jq::table true
        ;;
        * )
            echo type=$type
        ;;
    esac
}

private::data_sync(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r base=${args[base]:-remote}
    declare -r force=${args[force]:-false}

    declare -r data_int=$(private::data_int bool)
    if [[ $data_int == true ]] && [[ $force == false ]]; then
        reply_msg res='warning, data integrity test passed, use force=true to ignore' \
            return=$ERR_EXPR_FAILED show=true newline=false
    fi

    declare -r source=${args['source']:-${args['src']:-${args['s']:-undefined}}}
    if [[ $source == undefined ]]; then
        reply_msg res='error server name sourcer=NAME ?' \
            return=$ERR_EXPR_FAILED show=true newline=false
    fi

    # declare -r target=${args['target']:-${args['tar']:-${args['t']:-undefined}}}
    # if [[ $target == undefined ]]; then
    #     reply_msg res='error target=USERNAME ?' show=true return=$ERR_EXPR_FAILED
    # fi

    # declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    # declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}


    declare -ir server_id=$(yq '.servers[] | select(.location == "'$source'") | .id' $pool_servers_file)
    declare -r src_ssm_api_addr=$(yq '.servers[] | select(.id=='$server_id') | .api_addr + ":" + .api_port' $pool_servers_file)

    if [[ $base == remote ]]; then
        mapfile -t source_users < <(
            curl --silent --request GET --url http://${src_ssm_api_addr}/server/v1/users | \
            jq -r '.users[] | select(.username | test("^'${agent_prefix}'")) | .username + " " + .uPSK'
        )
    elif [[ $base == local ]]; then
        mapfile -t source_users < <(jq -r  '"_'${agent_id}'_" + .username + " " + .uPSK' $table_users/*.json)
    else
        reply_msg res="error base=$base not found" \
            return=$ERR_EXPR_FAILED show=true newline=false
    fi

    if (( ${#source_users[@]} ==  0 )); then
        reply_msg res="error source=$source not found, try: server list" \
            return=$ERR_EXPR_FAILED show=true newline=false
    fi

    ### iterate over all servers, exclude the source server
    mapfile -t server_ids < <(yq '.servers[] | select(.id != '$server_id') | .id' $pool_servers_file --output-format props)
    declare -A server_info=()

    # private::title ${args[silent]:-false} "id location username result"
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}

        for item in "${source_users[@]}"; do
            read ss_username password <<< "$item"
            private::printf ${args[silent]:-false} "create ${ss_username##_*_}"
            if curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users/$ss_username | jq --exit-status '.username=="'$ss_username'"' > /dev/null 2>&1; then
                private::print ${args[silent]:-false} "existed [${server_info[location]}]";
                continue
            else
                curl --silent --request POST --url http://${ssm_api_addr}/server/v1/users --data '{ "username": "'${ss_username}'", "uPSK": "'${password}'" }'
                private::print ${args[silent]:-false} "readded [${server_info[location]}]";
            fi
        done
    done

    ### fetch to refresh
    private::server_fetch silent=true $@

    reply_msg res=success ${@}
}

private::data_wipe(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    declare -r force=${args[force]:-false}

    ### generate a static page for it
    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done
    declare -r dash_path=${profile[web_root]}
    declare -r agent_dash=$dash_path/${agent_info[groupname]};
    declare -r agent_path=${db_info[root]}/${agent_info[groupname]};

    if [[ -d $agent_path ]]; then
        if [[ $force == true ]]; then
            find $agent_path -type f -not -name client.sample.json -delete
            rm -fr $agent_path/${db_info[archive]}/*
            rm -f $agent_dash/${agent_info[groupname]}.html
            find $agent_dash/* -type f -delete 2> /dev/null
            find $agent_dash/* -type d -delete 2> /dev/null
        else
            find $agent_path -type f -not -name client.sample.json
            find $agent_dash/* -type d 2> /dev/null
            echo $agent_dash/${agent_info[groupname]}.html
            reply_msg res="warning, use force=true to wipe all" \
                show=true return=$EXIT_SUCCESS
        fi
    else
        reply_msg res="error agent path $agent_path not found" \
            show=true return=$ERR_EXPR_FAILED
    fi
}

################################################################################
# db command
################################################################################
public::data(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(init info test sync wipe print);

    __action_list[init]='initialize database'
    __action_list[info]='info of a database';
    __action_list[test]='test database'
    __action_list[sync]='sync database'
    __action_list[wipe]='wipe all data in database'

    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
 
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        init | info | test | sync | wipe )
            # private::${__fn_name}_${__action} "$@";

            declare pfn=${__fn_name}_${__action}
            declare -r fn_call_result=$__log_path/$agent_id/${pfn}.txt

            if [[ ${args[bot]:-false} == false ]]; then
                { private::${pfn} "$@"; } |& tee -a $fn_call_result
            else
                declare -r fifo=${db_info[root]}/${agent_id}

                { private::${pfn} "$@" || true; } > $fifo 2>&1 &
                declare -ir pfn_job_pid=$!
                declare -r pfn_job_msg="new job for ${pfn/_/ } queued: <code>$pfn_job_pid</code>"
                echo -e "$pfn_job_msg" > $fifo 2>&1 &
                echo -e "$pfn_job_msg"

                declare -r doc_file=${fn_call_result%.txt}_${pfn_job_pid}.txt
                cat < $fifo > $doc_file

                declare -ir file_size=$(stat -c %s $doc_file)
                if (( file_size < 4096 )); then
                    cat $doc_file | tee -a $fn_call_result | private::telegram_msg aid=$agent_id silent=true code=true > /dev/null 2>&1
                else
                    private::telegram_doc aid=$agent_id silent=true file=$doc_file
                fi
            fi
        ;;
        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}


################################################################################
# telegram command
################################################################################
private::telegram_msg(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    # declare -r table_users=${db_info[root]}/${agent_info[groupname]}/${db_info[users]}
    # declare -r table_bytes=${db_info[root]}/${agent_info[groupname]}/${db_info[bytes]}
    # declare -r table_servers=${db_info[root]}/${agent_info[groupname]}/${db_info[servers]}
    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";


    ### check api.telegram.org access
    if ! nc -w3 -tzv  api.telegram.org 443 > /dev/null 2>&1; then
        reply_msg res='no access to api.telegram.org:443' \
        return=$ERR_EXPR_FAILED show=true newline=true
    fi

    declare -r username=${args['user']:-nobody}
    declare -r user_msg=${args['msg']:-}
    declare -r chat_id=${args['chid']:-}

    if [[ -p /dev/stdin ]]; then
        stdin_msg="$(< /dev/stdin)"
    else
        if [[ -z $user_msg ]]; then
            reply_msg res="error, msg=<string> ?" return=$ERR_EXPR_FAILED show=true
        fi
    fi

    declare -r date_now=$(date +%F-%A-%T)
    declare -r table_notifs=${db_info[root]}/${agent_info[groupname]}/${db_info[notifs]}

    if [[ ${args[code]:-false} == true ]]; then
        declare -r bot_text='"<code>'${user_msg:-$stdin_msg}'</code>"'
    else
        declare -r bot_text="${user_msg:-$stdin_msg}"
    fi

    echo $bot_text
    declare -r bot_token="${agent_info[bot_token]}"
    declare -r bot_chat_id=${chat_id:-"${agent_info[bot_chat_id]}"}
    declare -r bot_log_file=$table_notifs/${0%.sh}.json

    ### sendDocument -- https://core.telegram.org/bots/api#sendMessage
    curl -sL  \
        --retry 3 \
        --max-time 3 \
        --connect-timeout 3 \
        -o $bot_log_file \
        -F text="$bot_text" \
        -F chat_id="$bot_chat_id" \
        -F parse_mode="HTML" \
        -X POST \
        https://api.telegram.org/bot$bot_token/sendMessage

    ### validate the result
    declare -r send_doc_result=$(jq '.ok' < $bot_log_file)
    if [[ $send_doc_result == 'true' ]]; then
        echo "msg $date_now '$bot_text'" >>  $table_notifs/${username}.txt 2>&1
    else
        declare error_description=$(jq '.description' < $bot_log_file)
        echo "msg $date_now error: $error_description" >> $table_notifs/${username}.txt 2>&1
        exit 1
    fi

    reply_msg res=success $@
}

private::telegram_doc(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";


    ### check api.telegram.org access
    if ! nc -w3 -tzv  api.telegram.org 443 > /dev/null 2>&1; then
        reply_msg res='no access to api.telegram.org:443' \
        return=$ERR_EXPR_FAILED show=true newline=true
    fi

    declare -r username=${args['user']:-nobody}
    declare -r user_file=${args['file']:-}
    declare -r user_caption=${args['cap']:-}
    declare -r chat_id=${args['chid']:-}

    if ! [[ -f $user_file ]]; then
        reply_msg res="error, file=<file> ?" return=$ERR_EXPR_FAILED show=true
    fi

    declare -r date_now=$(date +%F-%A-%T)
    declare -r table_notifs=${db_info[root]}/${agent_info[groupname]}/${db_info[notifs]}

    declare -r bot_token="${agent_info[bot_token]}"
    declare -r bot_chat_id=${chat_id:-"${agent_info[bot_chat_id]}"}
    declare -r bot_log_file=$table_notifs/${0%.sh}.json

    ### sendDocument -- https://core.telegram.org/bots/api#senddocument
    curl -sL  \
        --retry 3 \
        --max-time 3 \
        --connect-timeout 3 \
        -o $bot_log_file \
        -F document=@"$user_file" \
        -F chat_id="$bot_chat_id" \
        -F parse_mode="HTML" \
        -F caption="$user_caption" \
        -X POST \
        https://api.telegram.org/bot$bot_token/sendDocument

    ### validate the result
    declare -r send_doc_result=$(jq '.ok' < $bot_log_file)
    if [[ $send_doc_result == 'true' ]]; then
        echo "doc $date_now '$user_file'" >> $table_notifs/${username}.txt 2>&1
    else
        declare -r error_description=$(jq '.description' < $bot_log_file)
        echo "doc $date_now error: $error_description" >> $table_notifs/${username}.txt 2>&1
        reply_msg res='error, see the notif log' $@
    fi

    reply_msg res=success newline=true $@
}

private::telegram_test(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::debug $LINENO "agent_info[@]: ${agent_info[@]}";

    private::telegram_msg msg="telegram test message from <b>${0##*/}</b> by ${agent_info[realname]}" \
        user=${agent_info[groupname]}

    reply_msg res=success $@
}


public::telegram(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(msg doc test print);

    __action_list[msg]='send a message/text'
    __action_list[doc]='send a document/file';
    __action_list[test]='test a notification'
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        msg | doc | test  )
            private::${__fn_name}_${__action} "$@";
        ;;
        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}


################################################################################
# app command
################################################################################
private::app_test_cmd() {
    declare -a cmds=(printf echo mkdir jq yq qrencode rsync nc mkfifo stat);

    for cmd in ${cmds[@]}; do
        if which $cmd > /dev/null 2>&1; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$cmd~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$cmd~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $cmd in
                yq )
                    echo "Install $cmd from here: https://github.com/mikefarah/yq";
                    exit $ERR_EXPR_FAILED
                ;;
                jq )
                    echo "Install $cmd from here: https://stedolan.github.io/jq/";
                    exit $ERR_EXPR_FAILED
                ;;
                printf | echo | qrencode | rsync )
                    echo "Install $cmd with your package manager";
                    exit $ERR_EXPR_FAILED
                ;;
                nc )
                    echo "Install netcat-openbsd with your package manager";
                    exit $ERR_EXPR_FAILED
                ;;
                * )
                    echo "no source found for: $cmd";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_dir() {
    declare -a dirs=(.prox/agent .prox/pool .prox/log .prox/tmp);

    for dir in ${dirs[@]}; do
        if [[ -d $dir ]]; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$dir~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$dir~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $dir in
                * )
                    echo "please mkdir $dir";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_file() {
    for ff in ${@}; do
        if [[ -f $ff ]]; then
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$ff~" "~" | tr ' ~' '. ';
            printf "passed\n";
        else
            printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "$ff~" "~" | tr ' ~' '. ';
            printf "failed, not found\n";
            case $ff in
                server.sample.json )
                    echo "$ff is optional on AAA server";
                ;;
                * )
                    echo "please add/configure $ff";
                    exit $ERR_EXPR_FAILED
                ;;
            esac
            echo
        fi
    done
}

private::app_test_server() {
    mapfile -t server_ids < <(yq ".servers[] | select(.active==true) | .id" $pool_servers_file --output-format props)
    for sid in "${server_ids[@]}"; do
        mapfile -t props < <(yq ".servers[$(($sid-1))]" $pool_servers_file --output-format props)
        declare -A server_info=()
        for line in "${props[@]}"; do
            IFS=\ =\  read key value <<< "$line"
            server_info[$key]="$value";
        done

        printf "%-${PRINTF_APP_TEST_OFFSET}s %s" "server=${server_info[location]}~" "~" | tr ' ~' '. ';
        ssm_api_addr=${server_info[api_addr]}:${server_info[api_port]}
        if nc -w3 -tzv ${server_info[api_addr]} ${server_info[api_port]} > /dev/null 2>&1; then
            curl --silent --request GET --url http://${ssm_api_addr}/server/v1/users | jq --exit-status '.' > /dev/null 2>&1
            printf "passed\n";
        else
            printf "failed, ${ssm_api_addr}\n";
            exit $ERR_EXPR_FAILED
        fi
    done
}

private::app_test(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    declare -r fn_caller=${FUNCNAME[1]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r client_sample_file=$__cc_path/${agent_id}.json
    private::title false "commands test:"
    private::app_test_cmd

    private::title false "\ndirectories test:"
    private::app_test_dir

    private::title false "\nfiles test:"
    private::app_test_file $agent_config_file $pool_servers_file \
        $client_sample_file

    private::title false "\nservers test:"
    private::app_test_server

    if [[ $fn_name == app_test ]]; then
        reply_msg res=success show=true newline=true $@
    fi
}

private::app_init(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    private::info false "### app tests"
    private::app_test

    private::info false "\n### data init"
    private::title false "init database:"
    private::data_init

    private::info false "\n### user create user=prox"
    ### check if shadowsocks outbound is found
    declare client_sample_file=$__cc_path/${agent_id}.json
    if ! jq -r --exit-status '[.outbounds[].type] | sort | unique | .[] | select(. == "shadowsocks")' $client_sample_file > /dev/null 2>&1; then
        reply_msg res="error shadowsocks outbound not found in your client config: $client_sample_file" \
            show=true newline=false return=$ERR_EXPR_FAILED
    fi
    private::user_create user=prox name=prox

    declare -A profile=()
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .profile' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        profile[$key]="$value";
    done

    declare -r dash_path=${profile[web_root]}
    declare -r user_profile_path=${dash_path}/${agent_info[groupname]}/prox

    private::info false "\n### done"
    private::print false "next, run a web server at ${profile[web_root]}/"
    private::print false "see local files here: $user_profile_path"
}

private::app_run(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    declare -r background=${args['back']:-${args['bg']:-${args['b']:-false}}}
    declare -r background_type=${args['type']:-prerun}
    declare -ir period=${args['period']:-${args['p']:-5}}

    if [[ $background == true ]] && [[ $background_type == prerun ]]; then
        echo "background: ${0} ${fn_name/_/ } aid=$agent_id bg=true (in +${period} minute)"
        echo "cd $PWD && ${0} ${fn_name/_/ } aid=$agent_id bg=true period=$period type=postrun" | at now +${period} minute > /dev/null 2>&1
        exit $EXIT_SUCCESS
    fi

    ### fetch data from servers
    echo "$(date '+%F-%A-%T'), aid: $agent_id"

    private::server_check aid=$agent_id $@
    echo

    private::server_fetch aid=$agent_id $@
    echo

    ### check user init or update
    private::user_init aid=$agent_id $@
    echo

    ### check user limits
    private::user_limit aid=$agent_id $@

    if [[ $background == true ]] && [[ $background_type == postrun ]]; then
        echo "cd $PWD && ${0} ${fn_name/_/ } aid=$agent_id bg=true period=$period type=postrun" | at now +${period} minute > /dev/null 2>&1
    fi

    reply_msg res=success ${@}
}

private::app_reset(){
    declare -r fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A args
    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done

    read -p 'YOU ARE 100% SURE? TYPE "YES" to proceed: ' confirm
    if [[ $confirm == YES ]]; then
        private::title ${args[silent]:-false} "user delete local users:"
        private::user_delete aid=$agent_id user=all force=true select=local

        private::title ${args[silent]:-false} "user delete remote users:"
        private::user_delete aid=$agent_id user=all force=true select=remote

        private::title ${args[silent]:-false} "data wipe:"
        private::data_wipe aid=$agent_id force=true
    fi
}


public::app(){
    declare -r __fn_name=${FUNCNAME[0]##*:};
    private::debug $LINENO ${FUNCNAME[@]};

    declare -A __action_list;
    declare -a __action_list_order;
    declare __action;

    declare -A agent_info=()
    declare -A pool_info=()

    __action_list_order=(test init run reset print);

    __action_list[test]='test dependencies'
    __action_list[init]='initialize the app'
    __action_list[run]='run the app'
    __action_list[reset]='reset the app (wipe data and users)'
    __action_list[print]='print';

    ### print available actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf "%-${PRINTF_HELP_OFFSET}s %s\n" $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action=${1};
        shift 1;
    fi
    
    ### initialize args
    declare -A args

    for pram in "${@}"; do
        IFS== read key value <<< "$pram"
        args[$key]="$value";
    done
    
    declare -r agent_id=${args['aid']:-}
    declare -r pool_id=${args['pid']:-}

    if [[ -z $agent_id ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, aid=NUMBER ?" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    declare -r agent_config_file=${__agent_path}/${agent_id}.yaml
    if ! [[ -f $agent_config_file ]]; then
        agent_info[id]=?
        agent_info[groupname]=?
        pool_info[id]=?
        reply_msg res="error, agent-id=$agent_id not found" return=$ERR_EXPR_FAILED \
            show=true newline=false
    fi

    ### check for errors in yaml file
    yq --exit-status  ".agent" $agent_config_file --output-format props > /dev/null

    ### map key and value
    mapfile -t tmp < <(yq ".agent" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        agent_info[$key]="$value";
    done

    ### check for access, exits on failure (no match found)
    declare -r agent_pool_id=${pool_id:-$(yq --exit-status '.agent.pool_id' $agent_config_file)}
    yq --exit-status ".pools[] | select(.id==$agent_pool_id)" $agent_config_file > /dev/null

    ### map key and value for pool_info
    mapfile -t tmp < <(yq ".pools[] | select(.id == $agent_pool_id)" $agent_config_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        pool_info[$key]="$value";
    done
    private::debug $LINENO "pool_info: ${pool_info[@]}";
    private::debug $LINENO "agent_pool_id: $agent_pool_id";

    declare -r pool_servers_file=${__pool_path}/${agent_pool_id}.yaml

    ### map key and value for db_info
    declare -A db_info=()
    db_info[name]=${agent_info[groupname]}
    db_info[root]=$(yq --exit-status '.db.root' $pool_servers_file)
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .tables' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    mapfile -t tmp < <(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .pass' $pool_servers_file --output-format props)
    for line in "${tmp[@]}"; do
        IFS=\ =\  read key value <<< "$line"
        db_info[$key]="$value";
    done
    private::debug $LINENO "db_info: ${db_info[@]}";

    # declare -r agent_prefix=$(yq '.db.info[] | select(.name=="'${agent_info[groupname]}'") | .prefix' $pool_servers_file)
    declare -r agent_prefix="_${agent_id}_"

    ### handle actions
    case ${__action} in
        print )
            echo print
        ;;
        init | test | run | reset )
            declare pfn=${__fn_name}_${__action}
            declare -r fn_call_result=$__log_path/$agent_id/${pfn}.txt
            if [[ ${args[bot]:-false} == false ]]; then
                { private::${pfn} "$@"; } |& tee -a $fn_call_result
            else
                declare -r fifo=${db_info[root]}/${agent_id}

                { private::${pfn} "$@" || true; } > $fifo 2>&1 &
                declare -ir pfn_job_pid=$!
                declare -r pfn_job_msg="new job for ${pfn/_/ } queued: <code>$pfn_job_pid</code>"
                echo -e "$pfn_job_msg" > $fifo 2>&1 &
                echo -e "$pfn_job_msg"

                declare -r doc_file=${fn_call_result%.txt}_${pfn_job_pid}.txt
                cat < $fifo > $doc_file

                declare -ir file_size=$(stat -c %s $doc_file)
                if (( file_size < 4096 )); then
                    cat $doc_file | tee -a $fn_call_result | private::telegram_msg aid=$agent_id silent=true code=true > /dev/null 2>&1
                else
                    private::telegram_doc aid=$agent_id silent=true file=$doc_file
                fi
            fi
        ;;
        * )
            reply_msg res="action [$__fn_name $__action], not found" return=$ERR_EXPR_FAILED \
                show=true newline=false
        ;;
    esac
}


################################################################################
# help and parse functions
################################################################################
private::cli_install(){
    if which $CLI_NAME > /dev/null 2>&1 ; then
        md5sum ./$CLI_NAME
        md5sum $CLI_INSTALL_PATH/$CLI_NAME;
        read -p "Already $CLI_NAME has been installed, want to overwrite [y/n]? " user_choice;
        case $user_choice in
            y )
                sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
                which $CLI_NAME;
            ;;
            * )
                printf "installing $0 cancelled\n";
                exit $EXIT_SUCCESS;

            ;;
        esac
    else
        sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
        which $CLI_NAME;
    fi

    exit $?;
}

private::cli_version(){
    printf "%s %s\n" $CLI_NAME $CLI_VERSION;
    printf "%s\n" $CLI_SOURCE_LINK;
    exit $EXIT_SUCCESS;
}

private::debug(){
    if [[ $SCRIPT_DEBUG_FLAG == true ]]; then
        printf "\033[1;33m${0} ($1) [${*:2}]\033[0m\n" 1>&2; 
    fi
}

private::debug_full(){
    set -x;
}

public::help(){
    printf "$ANSISHELL_HEADER";
    private::debug $LINENO $FUNCNAME ;

    printf "\n\nusage:\n";
    printf "$CLI_NAME [--options]\n";
    printf "$CLI_NAME [--options] command <subcommand> [arg=<arg>, ...]\n";

    printf "\noptions:\n";
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-h  | --help' 'show this help menu';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-v  | --version' 'show version';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-d  | --debug' 'enable debugging (script level)';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-D  | --DEBUG' 'enable bash debugging (bash level)';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" '-t  | --trap' 'enable trap for errors';

    printf "\ncommands:\n";
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'app    [a]' 'manage the app';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'server [s]' 'manage servers';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'agent  [ag]' 'manage agents';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'user   [u]' 'manage users';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'data   [d]' 'manage databases';
    printf "%-${PRINTF_HELP_OFFSET}s %s\n" 'tell   [t]' 'manage notifications (telegram) ';

    exit ${1:-1};
}

private::parse_options(){
    if (( ${#} == 0 )); then
        public::help 0;
    fi

    case $1 in
        -h | --help | help )
            public::help 0;
        ;;
        -d | --debug )
            SCRIPT_DEBUG_FLAG=true
            shift;
        ;;
        -D | --DEBUG )
            private::debug_full;
            shift;
        ;;
        -t | --trap )
            trap '__error_handing__ $? $LINENO' ERR
            shift;
        ;;
        -v | --version | version )
            private::cli_version;
            shift;
        ;;
    esac

    if (( ${#} != 0 )); then
        case ${1} in
            h | help | \
            a | app | \
            u | usr | user  | \
            s | srv | serv | server | \
            ag | agent | \
            d | db | data | \
            t | tell | telegram )
                private::debug $LINENO continue-main: "'$@'";
                private::main "$@";
            ;;
            * )
                printf "command: '%s' not found\n" $1;
                exit $ERR_EXPR_FAILED;
            ;;
        esac
    fi
}

################################################################################
# main function
################################################################################
private::main(){
    if (( ${#} == 0 )); then
        public::help 0;
    fi

    case ${1} in
        h | help | \
        a | app | \
        u | usr | user  | \
        s | srv | serv | server | \
        ag | agent | \
        d | db | data | \
        t | tell | telegram )
            private::debug $LINENO 'command:' "'${1}'";
            private::debug $LINENO 'command-options:' "'${@:2}'";
            public::${main_cmds[$1]} "${@:2}";
        ;;
        * )
            private::parse_options "$@";
        ;;
    esac
}

private::main "$@";
